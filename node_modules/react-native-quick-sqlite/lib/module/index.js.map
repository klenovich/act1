{"version":3,"names":["NativeModules","global","__QuickSQLiteProxy","QuickSQLiteModule","QuickSQLite","Error","nativeCallSyncHook","install","result","proxy","locks","enhanceQueryResult","rows","_array","length","item","idx","_open","open","dbName","location","queue","inProgress","_close","close","_execute","execute","query","params","_executeAsync","executeAsync","res","transaction","fn","isFinalized","commit","rollback","run","executionError","rollbackError","startNextTransaction","Promise","resolve","reject","tx","start","then","catch","push","shift","setImmediate","typeORMDriver","openDatabase","options","ok","fail","name","connection","executeSql","sql","response","e","attach","dbNameToAttach","alias","callback","detach","delete","executeBatch","commands","executeBatchAsync","loadFile","loadFileAsync"],"sources":["index.ts"],"sourcesContent":["import { NativeModules } from 'react-native';\n\ndeclare global {\n  function nativeCallSyncHook(): unknown;\n  var __QuickSQLiteProxy: object | undefined;\n}\n\nif (global.__QuickSQLiteProxy == null) {\n  const QuickSQLiteModule = NativeModules.QuickSQLite;\n\n  if (QuickSQLiteModule == null) {\n    throw new Error(\n      'Base quick-sqlite module not found. Maybe try rebuilding the app.'\n    );\n  }\n\n  // Check if we are running on-device (JSI)\n  if (global.nativeCallSyncHook == null || QuickSQLiteModule.install == null) {\n    throw new Error(\n      'Failed to install react-native-quick-sqlite: React Native is not running on-device. QuickSQLite can only be used when synchronous method invocations (JSI) are possible. If you are using a remote debugger (e.g. Chrome), switch to an on-device debugger (e.g. Flipper) instead.'\n    );\n  }\n\n  // Call the synchronous blocking install() function\n  const result = QuickSQLiteModule.install();\n  if (result !== true) {\n    throw new Error(\n      `Failed to install react-native-quick-sqlite: The native QuickSQLite Module could not be installed! Looks like something went wrong when installing JSI bindings: ${result}`\n    );\n  }\n\n  // Check again if the constructor now exists. If not, throw an error.\n  if (global.__QuickSQLiteProxy == null) {\n    throw new Error(\n      'Failed to install react-native-quick-sqlite, the native initializer function does not exist. Are you trying to use QuickSQLite from different JS Runtimes?'\n    );\n  }\n}\n\nconst proxy = global.__QuickSQLiteProxy;\nexport const QuickSQLite = proxy as ISQLite;\n\n/**\n * Object returned by SQL Query executions {\n *  insertId: Represent the auto-generated row id if applicable\n *  rowsAffected: Number of affected rows if result of a update query\n *  message: if status === 1, here you will find error description\n *  rows: if status is undefined or 0 this object will contain the query results\n * }\n *\n * @interface QueryResult\n */\nexport type QueryResult = {\n  insertId?: number;\n  rowsAffected: number;\n  rows?: {\n    /** Raw array with all dataset */\n    _array: any[];\n    /** The lengh of the dataset */\n    length: number;\n    /** A convenience function to acess the index based the row object\n     * @param idx the row index\n     * @returns the row structure identified by column names\n     */\n    item: (idx: number) => any;\n  };\n  /**\n   * Query metadata, avaliable only for select query results\n   */\n  metadata?: ColumnMetadata[];\n};\n\n/**\n * Column metadata\n * Describes some information about columns fetched by the query\n */\nexport type ColumnMetadata = {\n  /** The name used for this column for this resultset */\n  columnName: string;\n  /** The declared column type for this column, when fetched directly from a table or a View resulting from a table column. \"UNKNOWN\" for dynamic values, like function returned ones. */\n  columnDeclaredType: string;\n  /**\n   * The index for this column for this resultset*/\n  columnIndex: number;\n};\n\n/**\n * Allows the execution of bulk of sql commands\n * inside a transaction\n * If a single query must be executed many times with different arguments, its preferred\n * to declare it a single time, and use an array of array parameters.\n */\nexport type SQLBatchTuple = [string] | [string, Array<any> | Array<Array<any>>];\n\n/**\n * status: 0 or undefined for correct execution, 1 for error\n * message: if status === 1, here you will find error description\n * rowsAffected: Number of affected rows if status == 0\n */\nexport type BatchQueryResult = {\n  rowsAffected?: number;\n};\n\n/**\n * Result of loading a file and executing every line as a SQL command\n * Similar to BatchQueryResult\n */\nexport interface FileLoadResult extends BatchQueryResult {\n  commands?: number;\n}\n\nexport interface Transaction {\n  commit: () => QueryResult;\n  execute: (query: string, params?: any[]) => QueryResult;\n  executeAsync: (\n    query: string,\n    params?: any[] | undefined\n  ) => Promise<QueryResult>;\n  rollback: () => QueryResult;\n}\n\nexport interface PendingTransaction {\n  /*\n   * The start function should not throw or return a promise because the\n   * queue just calls it and does not monitor for failures or completions.\n   *\n   * It should catch any errors and call the resolve or reject of the wrapping\n   * promise when complete.\n   *\n   * It should also automatically commit or rollback the transaction if needed\n   */\n  start: () => void;\n}\n\ninterface ISQLite {\n  open: (dbName: string, location?: string) => void;\n  close: (dbName: string) => void;\n  delete: (dbName: string, location?: string) => void;\n  attach: (\n    mainDbName: string,\n    dbNameToAttach: string,\n    alias: string,\n    location?: string\n  ) => void;\n  detach: (mainDbName: string, alias: string) => void;\n  transaction: (\n    dbName: string,\n    fn: (tx: Transaction) => Promise<void> | void\n  ) => Promise<void>;\n  execute: (dbName: string, query: string, params?: any[]) => QueryResult;\n  executeAsync: (\n    dbName: string,\n    query: string,\n    params?: any[]\n  ) => Promise<QueryResult>;\n  executeBatch: (dbName: string, commands: SQLBatchTuple[]) => BatchQueryResult;\n  executeBatchAsync: (\n    dbName: string,\n    commands: SQLBatchTuple[]\n  ) => Promise<BatchQueryResult>;\n  loadFile: (dbName: string, location: string) => FileLoadResult;\n  loadFileAsync: (dbName: string, location: string) => Promise<FileLoadResult>;\n}\n\nconst locks: Record<\n  string,\n  { queue: PendingTransaction[]; inProgress: boolean }\n> = {};\n\n// Enhance some host functions\n\n// Add 'item' function to result object to allow the sqlite-storage typeorm driver to work\nconst enhanceQueryResult = (result: QueryResult): void => {\n  // Add 'item' function to result object to allow the sqlite-storage typeorm driver to work\n  if (result.rows == null) {\n    result.rows = {\n      _array: [],\n      length: 0,\n      item: (idx: number) => result.rows._array[idx],\n    };\n  } else {\n    result.rows.item = (idx: number) => result.rows._array[idx];\n  }\n};\n\nconst _open = QuickSQLite.open;\nQuickSQLite.open = (dbName: string, location?: string) => {\n  _open(dbName, location);\n\n  locks[dbName] = {\n    queue: [],\n    inProgress: false,\n  };\n};\n\nconst _close = QuickSQLite.close;\nQuickSQLite.close = (dbName: string) => {\n  _close(dbName);\n  delete locks[dbName];\n};\n\nconst _execute = QuickSQLite.execute;\nQuickSQLite.execute = (\n  dbName: string,\n  query: string,\n  params?: any[] | undefined\n): QueryResult => {\n  const result = _execute(dbName, query, params);\n  enhanceQueryResult(result);\n  return result;\n};\n\nconst _executeAsync = QuickSQLite.executeAsync;\nQuickSQLite.executeAsync = async (\n  dbName: string,\n  query: string,\n  params?: any[] | undefined\n): Promise<QueryResult> => {\n  const res = await _executeAsync(dbName, query, params);\n  enhanceQueryResult(res);\n  return res;\n};\n\nQuickSQLite.transaction = async (\n  dbName: string,\n  fn: (tx: Transaction) => Promise<void>\n): Promise<void> => {\n  if (!locks[dbName]) {\n    throw Error(`Quick SQLite Error: No lock found on db: ${dbName}`);\n  }\n\n  let isFinalized = false;\n\n  // Local transaction context object implementation\n  const execute = (query: string, params?: any[]): QueryResult => {\n    if (isFinalized) {\n      throw Error(\n        `Quick SQLite Error: Cannot execute query on finalized transaction: ${dbName}`\n      );\n    }\n    return QuickSQLite.execute(dbName, query, params);\n  };\n\n  const executeAsync = (query: string, params?: any[] | undefined) => {\n    if (isFinalized) {\n      throw Error(\n        `Quick SQLite Error: Cannot execute query on finalized transaction: ${dbName}`\n      );\n    }\n    return QuickSQLite.executeAsync(dbName, query, params);\n  };\n\n  const commit = () => {\n    if (isFinalized) {\n      throw Error(\n        `Quick SQLite Error: Cannot execute commit on finalized transaction: ${dbName}`\n      );\n    }\n    const result = QuickSQLite.execute(dbName, 'COMMIT');\n    isFinalized = true;\n    return result;\n  };\n\n  const rollback = () => {\n    if (isFinalized) {\n      throw Error(\n        `Quick SQLite Error: Cannot execute rollback on finalized transaction: ${dbName}`\n      );\n    }\n    const result = QuickSQLite.execute(dbName, 'ROLLBACK');\n    isFinalized = true;\n    return result;\n  };\n\n  async function run() {\n    try {\n      await QuickSQLite.executeAsync(dbName, 'BEGIN TRANSACTION');\n\n      await fn({\n        commit,\n        execute,\n        executeAsync,\n        rollback,\n      });\n\n      if (!isFinalized) {\n        commit();\n      }\n    } catch (executionError) {\n      if (!isFinalized) {\n        try {\n          rollback();\n        } catch (rollbackError) {\n          throw rollbackError;\n        }\n      }\n\n      throw executionError;\n    } finally {\n      locks[dbName].inProgress = false;\n      isFinalized = false;\n      startNextTransaction(dbName);\n    }\n  }\n\n  return await new Promise((resolve, reject) => {\n    const tx: PendingTransaction = {\n      start: () => {\n        run().then(resolve).catch(reject);\n      },\n    };\n\n    locks[dbName].queue.push(tx);\n    startNextTransaction(dbName);\n  });\n};\n\nconst startNextTransaction = (dbName: string) => {\n  if (!locks[dbName]) {\n    throw Error(`Lock not found for db: ${dbName}`);\n  }\n\n  if (locks[dbName].inProgress) {\n    // Transaction is already in process bail out\n    return;\n  }\n\n  if (locks[dbName].queue.length) {\n    locks[dbName].inProgress = true;\n    const tx = locks[dbName].queue.shift();\n    setImmediate(() => {\n      tx.start();\n    });\n  }\n};\n\n//   _________     _______  ______ ____  _____  __  __            _____ _____\n//  |__   __\\ \\   / /  __ \\|  ____/ __ \\|  __ \\|  \\/  |     /\\   |  __ \\_   _|\n//     | |   \\ \\_/ /| |__) | |__ | |  | | |__) | \\  / |    /  \\  | |__) || |\n//     | |    \\   / |  ___/|  __|| |  | |  _  /| |\\/| |   / /\\ \\ |  ___/ | |\n//     | |     | |  | |    | |___| |__| | | \\ \\| |  | |  / ____ \\| |    _| |_\n//     |_|     |_|  |_|    |______\\____/|_|  \\_\\_|  |_| /_/    \\_\\_|   |_____|\n\n/**\n * DO NOT USE THIS! THIS IS MEANT FOR TYPEORM\n * If you are looking for a convenience wrapper use `connect`\n */\nexport const typeORMDriver = {\n  openDatabase: (\n    options: {\n      name: string;\n      location?: string;\n    },\n    ok: (db: any) => void,\n    fail: (msg: string) => void\n  ): any => {\n    try {\n      QuickSQLite.open(options.name, options.location);\n\n      const connection = {\n        executeSql: async (\n          sql: string,\n          params: any[] | undefined,\n          ok: (res: QueryResult) => void,\n          fail: (msg: string) => void\n        ) => {\n          try {\n            let response = await QuickSQLite.executeAsync(\n              options.name,\n              sql,\n              params\n            );\n            enhanceQueryResult(response);\n            ok(response);\n          } catch (e) {\n            fail(e);\n          }\n        },\n        transaction: (\n          fn: (tx: Transaction) => Promise<void>\n        ): Promise<void> => {\n          return QuickSQLite.transaction(options.name, fn);\n        },\n        close: (ok: any, fail: any) => {\n          try {\n            QuickSQLite.close(options.name);\n            ok();\n          } catch (e) {\n            fail(e);\n          }\n        },\n        attach: (\n          dbNameToAttach: string,\n          alias: string,\n          location: string | undefined,\n          callback: () => void\n        ) => {\n          QuickSQLite.attach(options.name, dbNameToAttach, alias, location);\n\n          callback();\n        },\n        detach: (alias, callback: () => void) => {\n          QuickSQLite.detach(options.name, alias);\n\n          callback();\n        },\n      };\n\n      ok(connection);\n\n      return connection;\n    } catch (e) {\n      fail(e);\n    }\n  },\n};\n\nexport type QuickSQLiteConnection = {\n  close: () => void;\n  delete: () => void;\n  attach: (dbNameToAttach: string, alias: string, location?: string) => void;\n  detach: (alias: string) => void;\n  transaction: (fn: (tx: Transaction) => Promise<void> | void) => Promise<void>;\n  execute: (query: string, params?: any[]) => QueryResult;\n  executeAsync: (query: string, params?: any[]) => Promise<QueryResult>;\n  executeBatch: (commands: SQLBatchTuple[]) => BatchQueryResult;\n  executeBatchAsync: (commands: SQLBatchTuple[]) => Promise<BatchQueryResult>;\n  loadFile: (location: string) => FileLoadResult;\n  loadFileAsync: (location: string) => Promise<FileLoadResult>;\n};\n\nexport const open = (options: {\n  name: string;\n  location?: string;\n}): QuickSQLiteConnection => {\n  QuickSQLite.open(options.name, options.location);\n\n  return {\n    close: () => QuickSQLite.close(options.name),\n    delete: () => QuickSQLite.delete(options.name, options.location),\n    attach: (dbNameToAttach: string, alias: string, location?: string) =>\n      QuickSQLite.attach(options.name, dbNameToAttach, alias, location),\n    detach: (alias: string) => QuickSQLite.detach(options.name, alias),\n    transaction: (fn: (tx: Transaction) => Promise<void> | void) =>\n      QuickSQLite.transaction(options.name, fn),\n    execute: (query: string, params?: any[] | undefined): QueryResult =>\n      QuickSQLite.execute(options.name, query, params),\n    executeAsync: (\n      query: string,\n      params?: any[] | undefined\n    ): Promise<QueryResult> =>\n      QuickSQLite.executeAsync(options.name, query, params),\n    executeBatch: (commands: SQLBatchTuple[]) =>\n      QuickSQLite.executeBatch(options.name, commands),\n    executeBatchAsync: (commands: SQLBatchTuple[]) =>\n      QuickSQLite.executeBatchAsync(options.name, commands),\n    loadFile: (location: string) =>\n      QuickSQLite.loadFile(options.name, location),\n    loadFileAsync: (location: string) =>\n      QuickSQLite.loadFileAsync(options.name, location),\n  };\n};\n"],"mappings":"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"}