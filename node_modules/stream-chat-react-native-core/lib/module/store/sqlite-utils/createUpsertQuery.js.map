{"version":3,"names":["_schema","require","createUpsertQuery","table","row","conflictCheckKeys","filteredRow","key","undefined","fields","Object","keys","questionMarks","Array","length","fill","join","conflictKeys","tables","primaryKey","conflictMatchersWithoutPK","filter","f","includes","map","conflictConstraint","values","exports"],"sources":["createUpsertQuery.ts"],"sourcesContent":["import { Schema, tables } from '../schema';\nimport type { PreparedQueries, TableColumnNames, TableRow } from '../types';\n\n/**\n * Creates a simple upsert query for sqlite.\n *\n * @param {string} table Table name\n * @param {Object} row Table row to insert or update.\n * @param {Array} conflictCheckKeys Custom list of columns to check conflicts for - https://www.sqlite.org/lang_UPSERT.html. By default conflicts are checked on primary keys.\n * @returns {string} Final upsert query for sqlite\n */\nexport const createUpsertQuery = <T extends keyof Schema>(\n  table: T,\n  row: Partial<TableRow<T>>,\n  conflictCheckKeys?: Array<TableColumnNames<T>>,\n): PreparedQueries => {\n  const filteredRow: typeof row = {};\n\n  // In case of \"DO UPDATE SET\", we only want to update the properties which\n  // are provided, and not set undefined properties in database.\n  // E.g., channel date such as `own_capabilities` is only available in response of client.queryChannels or channel.query.\n  // But its not available in `event.channel`. And our mapper functions such as mapChannelToStorable will set fields which are not available as undefined.\n  // So when you execute upsert query for storable value of `event.channel` in `channels` table, it will\n  // unset ownCapabilities field for that channel in `channels` table.\n  for (const key in row) {\n    if (row[key] !== undefined) {\n      filteredRow[key] = row[key];\n    }\n  }\n  const fields = Object.keys(filteredRow) as (keyof typeof row)[];\n\n  const questionMarks = Array(Object.keys(fields).length).fill('?').join(',');\n  const conflictKeys = conflictCheckKeys || tables[table].primaryKey || [];\n  const conflictMatchersWithoutPK: string[] = (fields as string[])\n    .filter((f) => !(conflictKeys as string[]).includes(f))\n    .map((f) => `${f}=excluded.${f}`);\n\n  const conflictConstraint =\n    conflictKeys.length > 0\n      ? `ON CONFLICT(${conflictKeys.join(',')}) DO UPDATE SET\n  ${conflictMatchersWithoutPK.join(',')}`\n      : '';\n\n  return [\n    `INSERT INTO ${table} (${fields.join(',')}) VALUES (${questionMarks}) ${conflictConstraint}`,\n    Object.values(filteredRow),\n  ];\n};\n"],"mappings":";;;;AAAA,IAAAA,OAAA,GAAAC,OAAA;AAWO,IAAMC,iBAAiB,GAAG,SAApBA,iBAAiBA,CAC5BC,KAAQ,EACRC,GAAyB,EACzBC,iBAA8C,EAC1B;EACpB,IAAMC,WAAuB,GAAG,CAAC,CAAC;EAQlC,KAAK,IAAMC,GAAG,IAAIH,GAAG,EAAE;IACrB,IAAIA,GAAG,CAACG,GAAG,CAAC,KAAKC,SAAS,EAAE;MAC1BF,WAAW,CAACC,GAAG,CAAC,GAAGH,GAAG,CAACG,GAAG,CAAC;IAC7B;EACF;EACA,IAAME,MAAM,GAAGC,MAAM,CAACC,IAAI,CAACL,WAAW,CAAyB;EAE/D,IAAMM,aAAa,GAAGC,KAAK,CAACH,MAAM,CAACC,IAAI,CAACF,MAAM,CAAC,CAACK,MAAM,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC;EAC3E,IAAMC,YAAY,GAAGZ,iBAAiB,IAAIa,cAAM,CAACf,KAAK,CAAC,CAACgB,UAAU,IAAI,EAAE;EACxE,IAAMC,yBAAmC,GAAIX,MAAM,CAChDY,MAAM,CAAC,UAACC,CAAC;IAAA,OAAK,CAAEL,YAAY,CAAcM,QAAQ,CAACD,CAAC,CAAC;EAAA,EAAC,CACtDE,GAAG,CAAC,UAACF,CAAC;IAAA,OAAQA,CAAC,kBAAaA,CAAC;EAAA,CAAE,CAAC;EAEnC,IAAMG,kBAAkB,GACtBR,YAAY,CAACH,MAAM,GAAG,CAAC,oBACJG,YAAY,CAACD,IAAI,CAAC,GAAG,CAAC,2BACzCI,yBAAyB,CAACJ,IAAI,CAAC,GAAG,CAAC,GAC/B,EAAE;EAER,OAAO,kBACUb,KAAK,UAAKM,MAAM,CAACO,IAAI,CAAC,GAAG,CAAC,kBAAaJ,aAAa,UAAKa,kBAAkB,EAC1Ff,MAAM,CAACgB,MAAM,CAACpB,WAAW,CAAC,CAC3B;AACH,CAAC;AAACqB,OAAA,CAAAzB,iBAAA,GAAAA,iBAAA"}