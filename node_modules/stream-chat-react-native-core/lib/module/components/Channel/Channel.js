var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reactionData = exports.Channel = void 0;
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _debounce = _interopRequireDefault(require("lodash/debounce"));
var _throttle = _interopRequireDefault(require("lodash/throttle"));
var _mimeTypes = require("mime-types");
var _streamChat = require("stream-chat");
var _useCreateChannelContext = require("./hooks/useCreateChannelContext");
var _useCreateInputMessageInputContext = require("./hooks/useCreateInputMessageInputContext");
var _useCreateMessagesContext = require("./hooks/useCreateMessagesContext");
var _useCreateOwnCapabilitiesContext = require("./hooks/useCreateOwnCapabilitiesContext");
var _useCreatePaginatedMessageListContext = require("./hooks/useCreatePaginatedMessageListContext");
var _useCreateThreadContext = require("./hooks/useCreateThreadContext");
var _useCreateTypingContext = require("./hooks/useCreateTypingContext");
var _useTargetedMessage2 = require("./hooks/useTargetedMessage");
var _ChannelContext = require("../../contexts/channelContext/ChannelContext");
var _useChannelState2 = require("../../contexts/channelsStateContext/useChannelState");
var _ChatContext = require("../../contexts/chatContext/ChatContext");
var _MessageInputContext = require("../../contexts/messageInputContext/MessageInputContext");
var _MessagesContext = require("../../contexts/messagesContext/MessagesContext");
var _OwnCapabilitiesContext = require("../../contexts/ownCapabilitiesContext/OwnCapabilitiesContext");
var _PaginatedMessageListContext = require("../../contexts/paginatedMessageListContext/PaginatedMessageListContext");
var _SuggestionsContext = require("../../contexts/suggestionsContext/SuggestionsContext");
var _ThemeContext = require("../../contexts/themeContext/ThemeContext");
var _ThreadContext = require("../../contexts/threadContext/ThreadContext");
var _TranslationContext = require("../../contexts/translationContext/TranslationContext");
var _TypingContext = require("../../contexts/typingContext/TypingContext");
var _useAppStateListener = require("../../hooks/useAppStateListener");
var _icons = require("../../icons");
var _native = require("../../native");
var dbApi = _interopRequireWildcard(require("../../store/apis"));
var _addReactionToLocalState = require("../../utils/addReactionToLocalState");
var _DBSyncManager = require("../../utils/DBSyncManager");
var _patchMessageTextCommand = require("../../utils/patchMessageTextCommand");
var _removeReactionFromLocalState = require("../../utils/removeReactionFromLocalState");
var _utils = require("../../utils/utils");
var _Attachment = require("../Attachment/Attachment");
var _AttachmentActions = require("../Attachment/AttachmentActions");
var _AudioAttachment = require("../Attachment/AudioAttachment");
var _Card = require("../Attachment/Card");
var _FileAttachment = require("../Attachment/FileAttachment");
var _FileAttachmentGroup = require("../Attachment/FileAttachmentGroup");
var _FileIcon = require("../Attachment/FileIcon");
var _Gallery = require("../Attachment/Gallery");
var _Giphy = require("../Attachment/Giphy");
var _ImageLoadingFailedIndicator = require("../Attachment/ImageLoadingFailedIndicator");
var _ImageLoadingIndicator = require("../Attachment/ImageLoadingIndicator");
var _VideoThumbnail = require("../Attachment/VideoThumbnail");
var _AutoCompleteSuggestionHeader = require("../AutoCompleteInput/AutoCompleteSuggestionHeader");
var _AutoCompleteSuggestionItem = require("../AutoCompleteInput/AutoCompleteSuggestionItem");
var _AutoCompleteSuggestionList = require("../AutoCompleteInput/AutoCompleteSuggestionList");
var _EmptyStateIndicator = require("../Indicators/EmptyStateIndicator");
var _LoadingErrorIndicator = require("../Indicators/LoadingErrorIndicator");
var _LoadingIndicator = require("../Indicators/LoadingIndicator");
var _KeyboardCompatibleView = require("../KeyboardCompatibleView/KeyboardCompatibleView");
var _Message = require("../Message/Message");
var _MessageAvatar = require("../Message/MessageSimple/MessageAvatar");
var _MessageContent = require("../Message/MessageSimple/MessageContent");
var _MessageDeleted = require("../Message/MessageSimple/MessageDeleted");
var _MessageFooter = require("../Message/MessageSimple/MessageFooter");
var _MessagePinnedHeader = require("../Message/MessageSimple/MessagePinnedHeader");
var _MessageReplies = require("../Message/MessageSimple/MessageReplies");
var _MessageRepliesAvatars = require("../Message/MessageSimple/MessageRepliesAvatars");
var _MessageSimple = require("../Message/MessageSimple/MessageSimple");
var _MessageStatus = require("../Message/MessageSimple/MessageStatus");
var _ReactionList = require("../Message/MessageSimple/ReactionList");
var _AttachButton = require("../MessageInput/AttachButton");
var _CommandsButton = require("../MessageInput/CommandsButton");
var _InputEditingStateHeader = require("../MessageInput/components/InputEditingStateHeader");
var _InputGiphySearch = require("../MessageInput/components/InputGiphySearch");
var _InputReplyStateHeader = require("../MessageInput/components/InputReplyStateHeader");
var _CooldownTimer = require("../MessageInput/CooldownTimer");
var _FileUploadPreview = require("../MessageInput/FileUploadPreview");
var _ImageUploadPreview = require("../MessageInput/ImageUploadPreview");
var _InputButtons = require("../MessageInput/InputButtons");
var _MoreOptionsButton = require("../MessageInput/MoreOptionsButton");
var _SendButton = require("../MessageInput/SendButton");
var _SendMessageDisallowedIndicator = require("../MessageInput/SendMessageDisallowedIndicator");
var _ShowThreadMessageInChannelButton = require("../MessageInput/ShowThreadMessageInChannelButton");
var _UploadProgressIndicator = require("../MessageInput/UploadProgressIndicator");
var _DateHeader = require("../MessageList/DateHeader");
var _InlineDateSeparator = require("../MessageList/InlineDateSeparator");
var _InlineUnreadIndicator = require("../MessageList/InlineUnreadIndicator");
var _MessageList = require("../MessageList/MessageList");
var _MessageSystem = require("../MessageList/MessageSystem");
var _NetworkDownIndicator = require("../MessageList/NetworkDownIndicator");
var _ScrollToBottomButton = require("../MessageList/ScrollToBottomButton");
var _TypingIndicator = require("../MessageList/TypingIndicator");
var _TypingIndicatorContainer = require("../MessageList/TypingIndicatorContainer");
var _OverlayReactionList = require("../MessageOverlay/OverlayReactionList");
var _Reply = require("../Reply/Reply");
var _excluded = ["attachments", "mentioned_users", "parent_id", "text"],
  _excluded2 = ["channel_mutes", "devices", "mutes"],
  _excluded3 = ["__html", "attachments", "created_at", "deleted_at", "html", "id", "latest_reactions", "mentioned_users", "own_reactions", "parent_id", "quoted_message", "reaction_counts", "reactions", "status", "text", "type", "updated_at", "user"];
var _this = this,
  _jsxFileName = "/home/runner/work/stream-chat-react-native/stream-chat-react-native/package/src/components/Channel/Channel.tsx";
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var styles = _reactNative.StyleSheet.create({
  selectChannel: {
    fontWeight: 'bold',
    padding: 16
  }
});
var reactionData = [{
  Icon: _icons.LoveReaction,
  type: 'love'
}, {
  Icon: _icons.ThumbsUpReaction,
  type: 'like'
}, {
  Icon: _icons.ThumbsDownReaction,
  type: 'sad'
}, {
  Icon: _icons.LOLReaction,
  type: 'haha'
}, {
  Icon: _icons.WutReaction,
  type: 'wow'
}];
exports.reactionData = reactionData;
var scrollToFirstUnreadThreshold = 4;
var defaultThrottleInterval = 500;
var defaultDebounceInterval = 500;
var throttleOptions = {
  leading: true,
  trailing: true
};
var debounceOptions = {
  leading: true,
  trailing: true
};
var ChannelWithContext = function ChannelWithContext(props) {
  var _client$user, _channel$data, _ref26, _ref27;
  var additionalKeyboardAvoidingViewProps = props.additionalKeyboardAvoidingViewProps,
    additionalTextInputProps = props.additionalTextInputProps,
    additionalTouchableProps = props.additionalTouchableProps,
    _props$allowThreadMes = props.allowThreadMessagesInChannel,
    allowThreadMessagesInChannel = _props$allowThreadMes === void 0 ? true : _props$allowThreadMes,
    _props$AttachButton = props.AttachButton,
    AttachButton = _props$AttachButton === void 0 ? _AttachButton.AttachButton : _props$AttachButton,
    _props$Attachment = props.Attachment,
    Attachment = _props$Attachment === void 0 ? _Attachment.Attachment : _props$Attachment,
    _props$AttachmentActi = props.AttachmentActions,
    AttachmentActions = _props$AttachmentActi === void 0 ? _AttachmentActions.AttachmentActions : _props$AttachmentActi,
    _props$AudioAttachmen = props.AudioAttachment,
    AudioAttachment = _props$AudioAttachmen === void 0 ? _AudioAttachment.AudioAttachment : _props$AudioAttachmen,
    _props$AutoCompleteSu = props.AutoCompleteSuggestionHeader,
    AutoCompleteSuggestionHeader = _props$AutoCompleteSu === void 0 ? _AutoCompleteSuggestionHeader.AutoCompleteSuggestionHeader : _props$AutoCompleteSu,
    _props$AutoCompleteSu2 = props.AutoCompleteSuggestionItem,
    AutoCompleteSuggestionItem = _props$AutoCompleteSu2 === void 0 ? _AutoCompleteSuggestionItem.AutoCompleteSuggestionItem : _props$AutoCompleteSu2,
    _props$AutoCompleteSu3 = props.AutoCompleteSuggestionList,
    AutoCompleteSuggestionList = _props$AutoCompleteSu3 === void 0 ? _AutoCompleteSuggestionList.AutoCompleteSuggestionList : _props$AutoCompleteSu3,
    autoCompleteSuggestionsLimit = props.autoCompleteSuggestionsLimit,
    autoCompleteTriggerSettings = props.autoCompleteTriggerSettings,
    _props$Card = props.Card,
    Card = _props$Card === void 0 ? _Card.Card : _props$Card,
    CardCover = props.CardCover,
    CardFooter = props.CardFooter,
    CardHeader = props.CardHeader,
    channel = props.channel,
    children = props.children,
    client = props.client,
    _props$CommandsButton = props.CommandsButton,
    CommandsButton = _props$CommandsButton === void 0 ? _CommandsButton.CommandsButton : _props$CommandsButton,
    compressImageQuality = props.compressImageQuality,
    _props$CooldownTimer = props.CooldownTimer,
    CooldownTimer = _props$CooldownTimer === void 0 ? _CooldownTimer.CooldownTimer : _props$CooldownTimer,
    _props$DateHeader = props.DateHeader,
    DateHeader = _props$DateHeader === void 0 ? _DateHeader.DateHeader : _props$DateHeader,
    _props$deletedMessage = props.deletedMessagesVisibilityType,
    deletedMessagesVisibilityType = _props$deletedMessage === void 0 ? 'always' : _props$deletedMessage,
    _props$disableIfFroze = props.disableIfFrozenChannel,
    disableIfFrozenChannel = _props$disableIfFroze === void 0 ? true : _props$disableIfFroze,
    _props$disableKeyboar = props.disableKeyboardCompatibleView,
    disableKeyboardCompatibleView = _props$disableKeyboar === void 0 ? false : _props$disableKeyboar,
    disableTypingIndicator = props.disableTypingIndicator,
    _props$dismissKeyboar = props.dismissKeyboardOnMessageTouch,
    dismissKeyboardOnMessageTouch = _props$dismissKeyboar === void 0 ? true : _props$dismissKeyboar,
    doDocUploadRequest = props.doDocUploadRequest,
    doImageUploadRequest = props.doImageUploadRequest,
    doMarkReadRequest = props.doMarkReadRequest,
    doSendMessageRequest = props.doSendMessageRequest,
    doUpdateMessageRequest = props.doUpdateMessageRequest,
    _props$EmptyStateIndi = props.EmptyStateIndicator,
    EmptyStateIndicator = _props$EmptyStateIndi === void 0 ? _EmptyStateIndicator.EmptyStateIndicator : _props$EmptyStateIndi,
    _props$enableMessageG = props.enableMessageGroupingByUser,
    enableMessageGroupingByUser = _props$enableMessageG === void 0 ? true : _props$enableMessageG,
    enableOfflineSupport = props.enableOfflineSupport,
    _props$enforceUniqueR = props.enforceUniqueReaction,
    enforceUniqueReaction = _props$enforceUniqueR === void 0 ? false : _props$enforceUniqueR,
    _props$FileAttachment = props.FileAttachment,
    FileAttachment = _props$FileAttachment === void 0 ? _FileAttachment.FileAttachment : _props$FileAttachment,
    _props$FileAttachment2 = props.FileAttachmentGroup,
    FileAttachmentGroup = _props$FileAttachment2 === void 0 ? _FileAttachmentGroup.FileAttachmentGroup : _props$FileAttachment2,
    _props$FileAttachment3 = props.FileAttachmentIcon,
    FileAttachmentIcon = _props$FileAttachment3 === void 0 ? _FileIcon.FileIcon : _props$FileAttachment3,
    _props$FileUploadPrev = props.FileUploadPreview,
    FileUploadPreview = _props$FileUploadPrev === void 0 ? _FileUploadPreview.FileUploadPreview : _props$FileUploadPrev,
    _props$FlatList = props.FlatList,
    FlatList = _props$FlatList === void 0 ? _native.FlatList : _props$FlatList,
    forceAlignMessages = props.forceAlignMessages,
    formatDate = props.formatDate,
    _props$Gallery = props.Gallery,
    Gallery = _props$Gallery === void 0 ? _Gallery.Gallery : _props$Gallery,
    getMessagesGroupStyles = props.getMessagesGroupStyles,
    _props$Giphy = props.Giphy,
    Giphy = _props$Giphy === void 0 ? _Giphy.Giphy : _props$Giphy,
    giphyEnabled = props.giphyEnabled,
    _props$giphyVersion = props.giphyVersion,
    giphyVersion = _props$giphyVersion === void 0 ? 'fixed_height' : _props$giphyVersion,
    handleBlock = props.handleBlock,
    handleCopy = props.handleCopy,
    handleDelete = props.handleDelete,
    handleEdit = props.handleEdit,
    handleFlag = props.handleFlag,
    handleMute = props.handleMute,
    handlePinMessage = props.handlePinMessage,
    handleQuotedReply = props.handleQuotedReply,
    handleReaction = props.handleReaction,
    handleRetry = props.handleRetry,
    handleThreadReply = props.handleThreadReply,
    _props$hasCommands = props.hasCommands,
    hasCommands = _props$hasCommands === void 0 ? true : _props$hasCommands,
    _props$hasFilePicker = props.hasFilePicker,
    hasFilePicker = _props$hasFilePicker === void 0 ? _native.pickDocument !== null : _props$hasFilePicker,
    _props$hasImagePicker = props.hasImagePicker,
    hasImagePicker = _props$hasImagePicker === void 0 ? true : _props$hasImagePicker,
    _props$hideDateSepara = props.hideDateSeparators,
    hideDateSeparators = _props$hideDateSepara === void 0 ? false : _props$hideDateSepara,
    _props$hideStickyDate = props.hideStickyDateHeader,
    hideStickyDateHeader = _props$hideStickyDate === void 0 ? false : _props$hideStickyDate,
    _props$ImageUploadPre = props.ImageUploadPreview,
    ImageUploadPreview = _props$ImageUploadPre === void 0 ? _ImageUploadPreview.ImageUploadPreview : _props$ImageUploadPre,
    _props$initialScrollT = props.initialScrollToFirstUnreadMessage,
    initialScrollToFirstUnreadMessage = _props$initialScrollT === void 0 ? false : _props$initialScrollT,
    initialValue = props.initialValue,
    _props$InlineDateSepa = props.InlineDateSeparator,
    InlineDateSeparator = _props$InlineDateSepa === void 0 ? _InlineDateSeparator.InlineDateSeparator : _props$InlineDateSepa,
    _props$InlineUnreadIn = props.InlineUnreadIndicator,
    InlineUnreadIndicator = _props$InlineUnreadIn === void 0 ? _InlineUnreadIndicator.InlineUnreadIndicator : _props$InlineUnreadIn,
    Input = props.Input,
    _props$InputButtons = props.InputButtons,
    InputButtons = _props$InputButtons === void 0 ? _InputButtons.InputButtons : _props$InputButtons,
    _props$InputEditingSt = props.InputEditingStateHeader,
    InputEditingStateHeader = _props$InputEditingSt === void 0 ? _InputEditingStateHeader.InputEditingStateHeader : _props$InputEditingSt,
    _props$InputGiphySear = props.InputGiphySearch,
    InputGiphySearch = _props$InputGiphySear === void 0 ? _InputGiphySearch.InputGiphySearch : _props$InputGiphySear,
    _props$InputReplyStat = props.InputReplyStateHeader,
    InputReplyStateHeader = _props$InputReplyStat === void 0 ? _InputReplyStateHeader.InputReplyStateHeader : _props$InputReplyStat,
    isAttachmentEqual = props.isAttachmentEqual,
    keyboardBehavior = props.keyboardBehavior,
    _props$KeyboardCompat = props.KeyboardCompatibleView,
    KeyboardCompatibleView = _props$KeyboardCompat === void 0 ? _KeyboardCompatibleView.KeyboardCompatibleView : _props$KeyboardCompat,
    keyboardVerticalOffset = props.keyboardVerticalOffset,
    _props$legacyImageVie = props.legacyImageViewerSwipeBehaviour,
    legacyImageViewerSwipeBehaviour = _props$legacyImageVie === void 0 ? false : _props$legacyImageVie,
    _props$LoadingErrorIn = props.LoadingErrorIndicator,
    LoadingErrorIndicator = _props$LoadingErrorIn === void 0 ? _LoadingErrorIndicator.LoadingErrorIndicator : _props$LoadingErrorIn,
    _props$LoadingIndicat = props.LoadingIndicator,
    LoadingIndicator = _props$LoadingIndicat === void 0 ? _LoadingIndicator.LoadingIndicator : _props$LoadingIndicat,
    loadingMoreProp = props.loadingMore,
    loadingMoreRecentProp = props.loadingMoreRecent,
    _props$ImageLoadingFa = props.ImageLoadingFailedIndicator,
    ImageLoadingFailedIndicator = _props$ImageLoadingFa === void 0 ? _ImageLoadingFailedIndicator.ImageLoadingFailedIndicator : _props$ImageLoadingFa,
    _props$ImageLoadingIn = props.ImageLoadingIndicator,
    ImageLoadingIndicator = _props$ImageLoadingIn === void 0 ? _ImageLoadingIndicator.ImageLoadingIndicator : _props$ImageLoadingIn,
    markdownRules = props.markdownRules,
    maxMessageLengthProp = props.maxMessageLength,
    _props$maxNumberOfFil = props.maxNumberOfFiles,
    maxNumberOfFiles = _props$maxNumberOfFil === void 0 ? 10 : _props$maxNumberOfFil,
    maxTimeBetweenGroupedMessages = props.maxTimeBetweenGroupedMessages,
    _props$mentionAllAppU = props.mentionAllAppUsersEnabled,
    mentionAllAppUsersEnabled = _props$mentionAllAppU === void 0 ? false : _props$mentionAllAppU,
    mentionAllAppUsersQuery = props.mentionAllAppUsersQuery,
    members = props.members,
    _props$Message = props.Message,
    Message = _props$Message === void 0 ? _Message.Message : _props$Message,
    messageActions = props.messageActions,
    _props$MessageAvatar = props.MessageAvatar,
    MessageAvatar = _props$MessageAvatar === void 0 ? _MessageAvatar.MessageAvatar : _props$MessageAvatar,
    _props$MessageContent = props.MessageContent,
    MessageContent = _props$MessageContent === void 0 ? _MessageContent.MessageContent : _props$MessageContent,
    _props$messageContent = props.messageContentOrder,
    messageContentOrder = _props$messageContent === void 0 ? ['quoted_reply', 'gallery', 'files', 'text', 'attachments'] : _props$messageContent,
    _props$MessageDeleted = props.MessageDeleted,
    MessageDeleted = _props$MessageDeleted === void 0 ? _MessageDeleted.MessageDeleted : _props$MessageDeleted,
    _props$MessageFooter = props.MessageFooter,
    MessageFooter = _props$MessageFooter === void 0 ? _MessageFooter.MessageFooter : _props$MessageFooter,
    MessageHeader = props.MessageHeader,
    messageId = props.messageId,
    _props$MessageList = props.MessageList,
    MessageList = _props$MessageList === void 0 ? _MessageList.MessageList : _props$MessageList,
    _props$MessagePinnedH = props.MessagePinnedHeader,
    MessagePinnedHeader = _props$MessagePinnedH === void 0 ? _MessagePinnedHeader.MessagePinnedHeader : _props$MessagePinnedH,
    _props$MessageReplies = props.MessageReplies,
    MessageReplies = _props$MessageReplies === void 0 ? _MessageReplies.MessageReplies : _props$MessageReplies,
    _props$MessageReplies2 = props.MessageRepliesAvatars,
    MessageRepliesAvatars = _props$MessageReplies2 === void 0 ? _MessageRepliesAvatars.MessageRepliesAvatars : _props$MessageReplies2,
    messages = props.messages,
    _props$MessageSimple = props.MessageSimple,
    MessageSimple = _props$MessageSimple === void 0 ? _MessageSimple.MessageSimple : _props$MessageSimple,
    _props$MessageStatus = props.MessageStatus,
    MessageStatus = _props$MessageStatus === void 0 ? _MessageStatus.MessageStatus : _props$MessageStatus,
    _props$MessageSystem = props.MessageSystem,
    MessageSystem = _props$MessageSystem === void 0 ? _MessageSystem.MessageSystem : _props$MessageSystem,
    MessageText = props.MessageText,
    _props$MoreOptionsBut = props.MoreOptionsButton,
    MoreOptionsButton = _props$MoreOptionsBut === void 0 ? _MoreOptionsButton.MoreOptionsButton : _props$MoreOptionsBut,
    myMessageTheme = props.myMessageTheme,
    _props$newMessageStat = props.newMessageStateUpdateThrottleInterval,
    newMessageStateUpdateThrottleInterval = _props$newMessageStat === void 0 ? defaultThrottleInterval : _props$newMessageStat,
    _props$NetworkDownInd = props.NetworkDownIndicator,
    NetworkDownIndicator = _props$NetworkDownInd === void 0 ? _NetworkDownIndicator.NetworkDownIndicator : _props$NetworkDownInd,
    _props$numberOfLines = props.numberOfLines,
    numberOfLines = _props$numberOfLines === void 0 ? 5 : _props$numberOfLines,
    onChangeText = props.onChangeText,
    onLongPressMessage = props.onLongPressMessage,
    overrideOwnCapabilities = props.overrideOwnCapabilities,
    onPressInMessage = props.onPressInMessage,
    onPressMessage = props.onPressMessage,
    _props$OverlayReactio = props.OverlayReactionList,
    OverlayReactionList = _props$OverlayReactio === void 0 ? _OverlayReactionList.OverlayReactionList : _props$OverlayReactio,
    _props$ReactionList = props.ReactionList,
    ReactionList = _props$ReactionList === void 0 ? _ReactionList.ReactionList : _props$ReactionList,
    read = props.read,
    _props$Reply = props.Reply,
    Reply = _props$Reply === void 0 ? _Reply.Reply : _props$Reply,
    _props$ScrollToBottom = props.ScrollToBottomButton,
    ScrollToBottomButton = _props$ScrollToBottom === void 0 ? _ScrollToBottomButton.ScrollToBottomButton : _props$ScrollToBottom,
    selectReaction = props.selectReaction,
    _props$SendButton = props.SendButton,
    SendButton = _props$SendButton === void 0 ? _SendButton.SendButton : _props$SendButton,
    _props$SendMessageDis = props.SendMessageDisallowedIndicator,
    SendMessageDisallowedIndicator = _props$SendMessageDis === void 0 ? _SendMessageDisallowedIndicator.SendMessageDisallowedIndicator : _props$SendMessageDis,
    _props$sendImageAsync = props.sendImageAsync,
    sendImageAsync = _props$sendImageAsync === void 0 ? false : _props$sendImageAsync,
    setInputRef = props.setInputRef,
    setMembers = props.setMembers,
    setMessages = props.setMessages,
    setRead = props.setRead,
    setThreadMessages = props.setThreadMessages,
    setTyping = props.setTyping,
    setWatcherCount = props.setWatcherCount,
    setWatchers = props.setWatchers,
    shouldSyncChannel = props.shouldSyncChannel,
    _props$ShowThreadMess = props.ShowThreadMessageInChannelButton,
    ShowThreadMessageInChannelButton = _props$ShowThreadMess === void 0 ? _ShowThreadMessageInChannelButton.ShowThreadMessageInChannelButton : _props$ShowThreadMess,
    _props$stateUpdateThr = props.stateUpdateThrottleInterval,
    stateUpdateThrottleInterval = _props$stateUpdateThr === void 0 ? defaultThrottleInterval : _props$stateUpdateThr,
    StickyHeader = props.StickyHeader,
    _props$supportedReact = props.supportedReactions,
    supportedReactions = _props$supportedReact === void 0 ? reactionData : _props$supportedReact,
    t = props.t,
    threadProps = props.thread,
    threadList = props.threadList,
    threadMessages = props.threadMessages,
    typing = props.typing,
    _props$TypingIndicato = props.TypingIndicator,
    TypingIndicator = _props$TypingIndicato === void 0 ? _TypingIndicator.TypingIndicator : _props$TypingIndicato,
    _props$TypingIndicato2 = props.TypingIndicatorContainer,
    TypingIndicatorContainer = _props$TypingIndicato2 === void 0 ? _TypingIndicatorContainer.TypingIndicatorContainer : _props$TypingIndicato2,
    _props$UploadProgress = props.UploadProgressIndicator,
    UploadProgressIndicator = _props$UploadProgress === void 0 ? _UploadProgressIndicator.UploadProgressIndicator : _props$UploadProgress,
    _props$UrlPreview = props.UrlPreview,
    UrlPreview = _props$UrlPreview === void 0 ? _Card.Card : _props$UrlPreview,
    _props$VideoThumbnail = props.VideoThumbnail,
    VideoThumbnail = _props$VideoThumbnail === void 0 ? _VideoThumbnail.VideoThumbnail : _props$VideoThumbnail,
    watcherCount = props.watcherCount,
    watchers = props.watchers;
  var _useTheme = (0, _ThemeContext.useTheme)(),
    _useTheme$theme = _useTheme.theme,
    selectChannel = _useTheme$theme.channel.selectChannel,
    black = _useTheme$theme.colors.black;
  var _useState = (0, _react.useState)(false),
    _useState2 = (0, _slicedToArray2["default"])(_useState, 2),
    deleted = _useState2[0],
    setDeleted = _useState2[1];
  var _useState3 = (0, _react.useState)(false),
    _useState4 = (0, _slicedToArray2["default"])(_useState3, 2),
    editing = _useState4[0],
    setEditing = _useState4[1];
  var _useState5 = (0, _react.useState)(false),
    _useState6 = (0, _slicedToArray2["default"])(_useState5, 2),
    error = _useState6[0],
    setError = _useState6[1];
  var _useState7 = (0, _react.useState)(true),
    _useState8 = (0, _slicedToArray2["default"])(_useState7, 2),
    hasMore = _useState8[0],
    setHasMore = _useState8[1];
  var _useState9 = (0, _react.useState)(),
    _useState10 = (0, _slicedToArray2["default"])(_useState9, 2),
    lastRead = _useState10[0],
    setLastRead = _useState10[1];
  var _useState11 = (0, _react.useState)(!(channel != null && channel.state.messages.length)),
    _useState12 = (0, _slicedToArray2["default"])(_useState11, 2),
    loading = _useState12[0],
    setLoading = _useState12[1];
  var _useState13 = (0, _react.useState)(false),
    _useState14 = (0, _slicedToArray2["default"])(_useState13, 2),
    loadingMore = _useState14[0],
    setLoadingMore = _useState14[1];
  var _useState15 = (0, _react.useState)(false),
    _useState16 = (0, _slicedToArray2["default"])(_useState15, 2),
    loadingMoreRecent = _useState16[0],
    setLoadingMoreRecent = _useState16[1];
  var _useState17 = (0, _react.useState)(false),
    _useState18 = (0, _slicedToArray2["default"])(_useState17, 2),
    quotedMessage = _useState18[0],
    setQuotedMessage = _useState18[1];
  var _useState19 = (0, _react.useState)(threadProps || null),
    _useState20 = (0, _slicedToArray2["default"])(_useState19, 2),
    thread = _useState20[0],
    setThread = _useState20[1];
  var _useState21 = (0, _react.useState)(true),
    _useState22 = (0, _slicedToArray2["default"])(_useState21, 2),
    threadHasMore = _useState22[0],
    setThreadHasMore = _useState22[1];
  var _useState23 = (0, _react.useState)(false),
    _useState24 = (0, _slicedToArray2["default"])(_useState23, 2),
    threadLoadingMore = _useState24[0],
    setThreadLoadingMore = _useState24[1];
  var _useState25 = (0, _react.useState)(false),
    _useState26 = (0, _slicedToArray2["default"])(_useState25, 2),
    syncingChannel = _useState26[0],
    setSyncingChannel = _useState26[1];
  var _useState27 = (0, _react.useState)(true),
    _useState28 = (0, _slicedToArray2["default"])(_useState27, 2),
    hasNoMoreRecentMessagesToLoad = _useState28[0],
    setHasNoMoreRecentMessagesToLoad = _useState28[1];
  var _useTargetedMessage = (0, _useTargetedMessage2.useTargetedMessage)(),
    setTargetedMessage = _useTargetedMessage.setTargetedMessage,
    targetedMessage = _useTargetedMessage.targetedMessage;
  var channelId = (channel == null ? void 0 : channel.id) || '';
  (0, _react.useEffect)(function () {
    var initChannel = function initChannel() {
      if (!channel || !shouldSyncChannel || channel.offlineMode) return;
      if (!channel.initialized) {
        loadChannel();
        return;
      }
      if (messageId) {
        loadChannelAroundMessage({
          messageId: messageId
        });
        return;
      }
      if (initialScrollToFirstUnreadMessage && channel.countUnread() > scrollToFirstUnreadThreshold) {
        loadChannelAtFirstUnreadMessage();
      } else {
        loadChannel();
      }
    };
    initChannel();
    return function () {
      copyChannelState.cancel();
      copyReadState.cancel();
      copyTypingState.cancel();
      loadMoreFinished.cancel();
      loadMoreThreadFinished.cancel();
    };
  }, [channelId, messageId]);
  var threadPropsExists = !!threadProps;
  (0, _react.useEffect)(function () {
    if (threadProps && shouldSyncChannel) {
      setThread(threadProps);
      if (channel && threadProps != null && threadProps.id) {
        var _channel$state$thread;
        setThreadMessages(((_channel$state$thread = channel.state.threads) == null ? void 0 : _channel$state$thread[threadProps.id]) || []);
      }
    } else {
      setThread(null);
    }
  }, [threadPropsExists, shouldSyncChannel]);
  var handleAppBackground = (0, _react.useCallback)(function () {
    var _channelData$own_capa;
    var channelData = channel.data;
    if (channelData != null && (_channelData$own_capa = channelData.own_capabilities) != null && _channelData$own_capa.includes('send-typing-events')) {
      channel.sendEvent({
        parent_id: thread == null ? void 0 : thread.id,
        type: 'typing.stop'
      });
    }
  }, [thread == null ? void 0 : thread.id, channelId]);
  (0, _useAppStateListener.useAppStateListener)(undefined, handleAppBackground);
  var isAdmin = (client == null ? void 0 : (_client$user = client.user) == null ? void 0 : _client$user.role) === 'admin' || (channel == null ? void 0 : channel.state.membership.role) === 'admin';
  var isModerator = (channel == null ? void 0 : channel.state.membership.role) === 'channel_moderator' || (channel == null ? void 0 : channel.state.membership.role) === 'moderator';
  var isOwner = (channel == null ? void 0 : channel.state.membership.role) === 'owner';
  var markRead = (0, _react.useRef)((0, _throttle["default"])(function () {
    if (!channel || channel != null && channel.disconnected || !(clientChannelConfig != null && clientChannelConfig.read_events)) {
      return;
    }
    if (doMarkReadRequest) {
      doMarkReadRequest(channel);
    } else {
      (0, _streamChat.logChatPromiseExecution)(channel.markRead(), 'mark read');
    }
  }, defaultThrottleInterval, throttleOptions)).current;
  var copyMessagesState = (0, _react.useRef)((0, _throttle["default"])(function () {
    if (channel) {
      setMessages((0, _toConsumableArray2["default"])(channel.state.messages));
    }
  }, newMessageStateUpdateThrottleInterval, throttleOptions)).current;
  var copyTypingState = (0, _react.useRef)((0, _throttle["default"])(function () {
    if (channel) {
      setTyping((0, _extends2["default"])({}, channel.state.typing));
    }
  }, stateUpdateThrottleInterval, throttleOptions)).current;
  var copyReadState = (0, _react.useRef)((0, _throttle["default"])(function () {
    if (channel) {
      setRead((0, _extends2["default"])({}, channel.state.read));
    }
  }, stateUpdateThrottleInterval, throttleOptions)).current;
  var copyChannelState = (0, _react.useRef)((0, _throttle["default"])(function () {
    setLoading(false);
    if (channel) {
      setMembers((0, _extends2["default"])({}, channel.state.members));
      setMessages((0, _toConsumableArray2["default"])(channel.state.messages));
      setRead((0, _extends2["default"])({}, channel.state.read));
      setTyping((0, _extends2["default"])({}, channel.state.typing));
      setWatcherCount(channel.state.watcher_count);
      setWatchers((0, _extends2["default"])({}, channel.state.watchers));
    }
  }, stateUpdateThrottleInterval, throttleOptions)).current;
  (0, _react.useEffect)(function () {
    var channelSubscriptions = [];
    if (channel && shouldSyncChannel) {
      channelSubscriptions.push(channel.on('message.new', copyMessagesState));
      channelSubscriptions.push(channel.on('message.read', copyReadState));
      channelSubscriptions.push(channel.on('typing.start', copyTypingState));
      channelSubscriptions.push(channel.on('typing.stop', copyTypingState));
    }
    return function () {
      channelSubscriptions.forEach(function (s) {
        return s.unsubscribe();
      });
    };
  }, [channelId, shouldSyncChannel]);
  (0, _react.useEffect)(function () {
    var handleEvent = function handleEvent(event) {
      if (shouldSyncChannel) {
        var _event$message;
        if (thread) {
          var updatedThreadMessages = thread.id && channel && channel.state.threads[thread.id] || threadMessages;
          setThreadMessages(updatedThreadMessages);
        }
        if (channel && thread && ((_event$message = event.message) == null ? void 0 : _event$message.id) === thread.id) {
          var updatedThread = channel.state.formatMessage(event.message);
          setThread(updatedThread);
        }
        if (channel && event.type !== 'message.new' && event.type !== 'message.read' && event.type !== 'typing.start' && event.type !== 'typing.stop') {
          copyChannelState();
        }
      }
    };
    var _channel$on = channel.on(handleEvent),
      unsubscribe = _channel$on.unsubscribe;
    return unsubscribe;
  }, [channelId, thread == null ? void 0 : thread.id, shouldSyncChannel]);
  (0, _react.useEffect)(function () {
    var _client$on = client.on('channel.deleted', function (event) {
        if (event.cid === (channel == null ? void 0 : channel.cid)) {
          setDeleted(true);
        }
      }),
      unsubscribe = _client$on.unsubscribe;
    return unsubscribe;
  }, [channelId]);
  var channelQueryCallRef = (0, _react.useRef)(function () {
    var _ref = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(queryCall) {
      var onAfterQueryCall,
        _args = arguments;
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            onAfterQueryCall = _args.length > 1 && _args[1] !== undefined ? _args[1] : undefined;
            setError(false);
            _context.prev = 2;
            _context.next = 5;
            return queryCall();
          case 5:
            setLastRead(new Date());
            setHasMore(true);
            copyChannelState();
            onAfterQueryCall == null ? void 0 : onAfterQueryCall();
            _context.next = 16;
            break;
          case 11:
            _context.prev = 11;
            _context.t0 = _context["catch"](2);
            if (_context.t0 instanceof Error) {
              setError(_context.t0);
            } else {
              setError(true);
            }
            setLoading(false);
            setLastRead(new Date());
          case 16:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[2, 11]]);
    }));
    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }());
  var loadChannelAtFirstUnreadMessage = function loadChannelAtFirstUnreadMessage() {
    if (!channel) return;
    var unreadMessageIdToScrollTo;
    return channelQueryCallRef.current((0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2() {
      var lastReadDate, _channel$state$messag;
      return _regenerator["default"].wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            setLoading(true);
            lastReadDate = channel.lastRead();
            if (!lastReadDate) {
              _context2.next = 9;
              break;
            }
            setHasNoMoreRecentMessagesToLoad(false);
            _context2.next = 6;
            return channel.query({
              messages: {
                created_at_around: lastReadDate,
                limit: 30
              }
            }, 'new');
          case 6:
            unreadMessageIdToScrollTo = (_channel$state$messag = channel.state.messages.find(function (m) {
              return lastReadDate < m.created_at;
            })) == null ? void 0 : _channel$state$messag.id;
            _context2.next = 11;
            break;
          case 9:
            _context2.next = 11;
            return channel.state.loadMessageIntoState('latest');
          case 11:
            setLoading(false);
          case 12:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    })), function () {
      if (unreadMessageIdToScrollTo) {
        setTargetedMessage(unreadMessageIdToScrollTo);
      }
    });
  };
  var loadChannelAroundMessage = function loadChannelAroundMessage(_ref3) {
    var messageId = _ref3.messageId;
    return channelQueryCallRef.current((0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee3() {
      return _regenerator["default"].wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            setHasNoMoreRecentMessagesToLoad(false);
            setLoading(true);
            if (!messageId) {
              _context3.next = 7;
              break;
            }
            _context3.next = 5;
            return channel.state.loadMessageIntoState(messageId);
          case 5:
            _context3.next = 10;
            break;
          case 7:
            _context3.next = 9;
            return channel.state.loadMessageIntoState('latest');
          case 9:
            channel.state.setIsUpToDate(true);
          case 10:
            setLoading(false);
          case 11:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    })), function () {
      if (messageId) {
        setTargetedMessage(messageId);
      }
    });
  };
  var loadChannelAtMessage = function loadChannelAtMessage(_ref5) {
    var _ref5$after = _ref5.after,
      after = _ref5$after === void 0 ? 2 : _ref5$after,
      _ref5$before = _ref5.before,
      before = _ref5$before === void 0 ? 30 : _ref5$before,
      messageId = _ref5.messageId;
    return channelQueryCallRef.current((0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee4() {
      return _regenerator["default"].wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return queryAtMessage({
              after: after,
              before: before,
              messageId: messageId
            });
          case 2:
            if (messageId) {
              setTargetedMessage(messageId);
            }
          case 3:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    })));
  };
  var loadChannel = function loadChannel() {
    return channelQueryCallRef.current((0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee5() {
      return _regenerator["default"].wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            if (!(!(channel != null && channel.initialized) || !channel.state.isUpToDate)) {
              _context5.next = 7;
              break;
            }
            _context5.next = 3;
            return channel == null ? void 0 : channel.watch();
          case 3:
            setHasNoMoreRecentMessagesToLoad(true);
            channel == null ? void 0 : channel.state.setIsUpToDate(true);
            _context5.next = 9;
            break;
          case 7:
            _context5.next = 9;
            return channel.state.loadMessageIntoState('latest');
          case 9:
            return _context5.abrupt("return");
          case 10:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    })));
  };
  var reloadThread = function () {
    var _ref8 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee6() {
      var parentID, limit, queryResponse, updatedHasMore, updatedThreadMessages, _yield$channel$getMes, _messages, _messages2, threadMessage, formattedMessage;
      return _regenerator["default"].wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            if (!(!channel || !(thread != null && thread.id))) {
              _context6.next = 2;
              break;
            }
            return _context6.abrupt("return");
          case 2:
            setThreadLoadingMore(true);
            _context6.prev = 3;
            parentID = thread.id;
            limit = 50;
            channel.state.threads[parentID] = [];
            _context6.next = 9;
            return channel.getReplies(parentID, {
              limit: limit
            });
          case 9:
            queryResponse = _context6.sent;
            updatedHasMore = queryResponse.messages.length === limit;
            updatedThreadMessages = channel.state.threads[parentID] || [];
            loadMoreThreadFinished(updatedHasMore, updatedThreadMessages);
            _context6.next = 15;
            return channel.getMessagesById([parentID]);
          case 15:
            _yield$channel$getMes = _context6.sent;
            _messages = _yield$channel$getMes.messages;
            _messages2 = (0, _slicedToArray2["default"])(_messages, 1), threadMessage = _messages2[0];
            if (threadMessage) {
              formattedMessage = channel.state.formatMessage(threadMessage);
              setThread(formattedMessage);
            }
            _context6.next = 27;
            break;
          case 21:
            _context6.prev = 21;
            _context6.t0 = _context6["catch"](3);
            console.warn('Thread loading request failed with error', _context6.t0);
            if (_context6.t0 instanceof Error) {
              setError(_context6.t0);
            } else {
              setError(true);
            }
            setThreadLoadingMore(false);
            throw _context6.t0;
          case 27:
          case "end":
            return _context6.stop();
        }
      }, _callee6, null, [[3, 21]]);
    }));
    return function reloadThread() {
      return _ref8.apply(this, arguments);
    };
  }();
  var resyncChannel = function () {
    var _ref9 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee7() {
      var _messages$, state, oldListTopMessage, oldListTopMessageId, oldListBottomMessage, newListTopMessage, newListBottomMessage, parseMessage, failedMessages, failedThreadMessages, oldListTopMessageCreatedAt, oldListBottomMessageCreatedAt, newListTopMessageCreatedAt, newListBottomMessageCreatedAt, finalMessages, index;
      return _regenerator["default"].wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            if (!(!channel || syncingChannel)) {
              _context7.next = 2;
              break;
            }
            return _context7.abrupt("return");
          case 2:
            setSyncingChannel(true);
            setError(false);
            _context7.prev = 4;
            _context7.next = 7;
            return channel.watch({
              messages: {
                limit: messages.length + 30
              }
            });
          case 7:
            state = _context7.sent;
            oldListTopMessage = messages[0];
            oldListTopMessageId = (_messages$ = messages[0]) == null ? void 0 : _messages$.id;
            oldListBottomMessage = messages[messages.length - 1];
            newListTopMessage = state.messages[0];
            newListBottomMessage = state.messages[state.messages.length - 1];
            if (!(!oldListTopMessage || !oldListBottomMessage || !newListTopMessage || !newListBottomMessage)) {
              _context7.next = 20;
              break;
            }
            channel.state.clearMessages();
            channel.state.setIsUpToDate(true);
            channel.state.addMessagesSorted(state.messages);
            channel.state.addPinnedMessages(state.pinned_messages);
            copyChannelState();
            return _context7.abrupt("return");
          case 20:
            parseMessage = function parseMessage(message) {
              var _message$pinned_at, _message$updated_at;
              return (0, _extends2["default"])({}, message, {
                created_at: message.created_at.toString(),
                pinned_at: (_message$pinned_at = message.pinned_at) == null ? void 0 : _message$pinned_at.toString(),
                updated_at: (_message$updated_at = message.updated_at) == null ? void 0 : _message$updated_at.toString()
              });
            };
            failedMessages = messages.filter(function (message) {
              return message.status === _utils.MessageStatusTypes.FAILED;
            }).map(parseMessage);
            failedThreadMessages = thread ? threadMessages.filter(function (message) {
              return message.status === _utils.MessageStatusTypes.FAILED;
            }).map(parseMessage) : [];
            oldListTopMessageCreatedAt = oldListTopMessage.created_at;
            oldListBottomMessageCreatedAt = oldListBottomMessage.created_at;
            newListTopMessageCreatedAt = newListTopMessage.created_at ? new Date(newListTopMessage.created_at) : new Date();
            newListBottomMessageCreatedAt = newListBottomMessage != null && newListBottomMessage.created_at ? new Date(newListBottomMessage.created_at) : new Date();
            finalMessages = [];
            if (oldListTopMessage && oldListTopMessageCreatedAt && oldListBottomMessageCreatedAt && newListTopMessageCreatedAt < oldListTopMessageCreatedAt && newListBottomMessageCreatedAt >= oldListBottomMessageCreatedAt) {
              index = state.messages.findIndex(function (message) {
                return message.id === oldListTopMessageId;
              });
              finalMessages = state.messages.slice(index);
            } else {
              finalMessages = state.messages;
            }
            setHasNoMoreRecentMessagesToLoad(true);
            channel.state.setIsUpToDate(true);
            channel.state.clearMessages();
            channel.state.addMessagesSorted(finalMessages);
            channel.state.addPinnedMessages(state.pinned_messages);
            setHasMore(true);
            copyChannelState();
            if (failedMessages.length) {
              channel.state.addMessagesSorted(failedMessages);
              copyChannelState();
            }
            _context7.next = 39;
            return reloadThread();
          case 39:
            if (thread && failedThreadMessages.length) {
              channel.state.addMessagesSorted(failedThreadMessages);
              setThreadMessages((0, _toConsumableArray2["default"])(channel.state.threads[thread.id]));
            }
            _context7.next = 46;
            break;
          case 42:
            _context7.prev = 42;
            _context7.t0 = _context7["catch"](4);
            if (_context7.t0 instanceof Error) {
              setError(_context7.t0);
            } else {
              setError(true);
            }
            setLoading(false);
          case 46:
            setSyncingChannel(false);
          case 47:
          case "end":
            return _context7.stop();
        }
      }, _callee7, null, [[4, 42]]);
    }));
    return function resyncChannel() {
      return _ref9.apply(this, arguments);
    };
  }();
  var resyncChannelRef = (0, _react.useRef)(resyncChannel);
  resyncChannelRef.current = resyncChannel;
  (0, _react.useEffect)(function () {
    var connectionChangedHandler = function connectionChangedHandler() {
      if (shouldSyncChannel) {
        resyncChannelRef.current();
      }
    };
    var connectionChangedSubscription;
    if (enableOfflineSupport) {
      connectionChangedSubscription = _DBSyncManager.DBSyncManager.onSyncStatusChange(connectionChangedHandler);
    } else {
      connectionChangedSubscription = client.on('connection.changed', function (event) {
        if (event.online) {
          connectionChangedHandler();
        }
      });
    }
    return function () {
      connectionChangedSubscription.unsubscribe();
    };
  }, [enableOfflineSupport, shouldSyncChannel]);
  var reloadChannel = function reloadChannel() {
    return channelQueryCallRef.current((0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee8() {
      return _regenerator["default"].wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            setLoading(true);
            _context8.next = 3;
            return channel.state.loadMessageIntoState('latest');
          case 3:
            setLoading(false);
            setHasNoMoreRecentMessagesToLoad(true);
            channel == null ? void 0 : channel.state.setIsUpToDate(true);
          case 6:
          case "end":
            return _context8.stop();
        }
      }, _callee8);
    })));
  };
  var queryAtMessage = function () {
    var _ref12 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee9(_ref11) {
      var _ref11$after, after, _ref11$before, before, messageId;
      return _regenerator["default"].wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            _ref11$after = _ref11.after, after = _ref11$after === void 0 ? 10 : _ref11$after, _ref11$before = _ref11.before, before = _ref11$before === void 0 ? 10 : _ref11$before, messageId = _ref11.messageId;
            if (channel) {
              _context9.next = 3;
              break;
            }
            return _context9.abrupt("return");
          case 3:
            channel.state.setIsUpToDate(false);
            channel.state.clearMessages();
            setMessages((0, _toConsumableArray2["default"])(channel.state.messages));
            if (messageId) {
              _context9.next = 11;
              break;
            }
            _context9.next = 9;
            return channel.query({
              messages: {
                limit: before
              },
              watch: true
            });
          case 9:
            channel.state.setIsUpToDate(true);
            return _context9.abrupt("return");
          case 11:
            _context9.next = 13;
            return queryBeforeMessage(messageId, before);
          case 13:
            _context9.next = 15;
            return queryAfterMessage(messageId, after);
          case 15:
          case "end":
            return _context9.stop();
        }
      }, _callee9);
    }));
    return function queryAtMessage(_x2) {
      return _ref12.apply(this, arguments);
    };
  }();
  var queryBeforeMessage = function () {
    var _ref13 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee10(messageId) {
      var limit,
        _args10 = arguments;
      return _regenerator["default"].wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            limit = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : 5;
            if (channel) {
              _context10.next = 3;
              break;
            }
            return _context10.abrupt("return");
          case 3:
            _context10.next = 5;
            return channel.query({
              messages: {
                id_lt: messageId,
                limit: limit
              },
              watch: true
            });
          case 5:
            channel.state.setIsUpToDate(false);
          case 6:
          case "end":
            return _context10.stop();
        }
      }, _callee10);
    }));
    return function queryBeforeMessage(_x3) {
      return _ref13.apply(this, arguments);
    };
  }();
  var queryAfterMessage = function () {
    var _ref14 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee11(messageId) {
      var limit,
        state,
        _args11 = arguments;
      return _regenerator["default"].wrap(function _callee11$(_context11) {
        while (1) switch (_context11.prev = _context11.next) {
          case 0:
            limit = _args11.length > 1 && _args11[1] !== undefined ? _args11[1] : 5;
            if (channel) {
              _context11.next = 3;
              break;
            }
            return _context11.abrupt("return");
          case 3:
            _context11.next = 5;
            return channel.query({
              messages: {
                id_gte: messageId,
                limit: limit
              },
              watch: true
            });
          case 5:
            state = _context11.sent;
            if (state.messages.length < limit) {
              channel.state.setIsUpToDate(true);
            } else {
              channel.state.setIsUpToDate(false);
            }
          case 7:
          case "end":
            return _context11.stop();
        }
      }, _callee11);
    }));
    return function queryAfterMessage(_x4) {
      return _ref14.apply(this, arguments);
    };
  }();
  var getChannelConfigSafely = function getChannelConfigSafely() {
    try {
      return channel == null ? void 0 : channel.getConfig();
    } catch (_) {
      return null;
    }
  };
  var clientChannelConfig = getChannelConfigSafely();
  var updateMessage = function updateMessage(updatedMessage) {
    var extraState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (channel) {
      channel.state.addMessageSorted(updatedMessage, true);
      if (thread && updatedMessage.parent_id) {
        extraState.threadMessages = channel.state.threads[updatedMessage.parent_id] || [];
        setThreadMessages(extraState.threadMessages);
      }
      setMessages((0, _toConsumableArray2["default"])(channel.state.messages));
    }
  };
  var replaceMessage = function replaceMessage(oldMessage, newMessage) {
    if (channel) {
      channel.state.removeMessage(oldMessage);
      channel.state.addMessageSorted(newMessage, true);
      if (thread && newMessage.parent_id) {
        var _threadMessages = channel.state.threads[newMessage.parent_id] || [];
        setThreadMessages(_threadMessages);
      }
      setMessages(channel.state.messages);
    }
  };
  var createMessagePreview = function createMessagePreview(_ref15) {
    var attachments = _ref15.attachments,
      mentioned_users = _ref15.mentioned_users,
      parent_id = _ref15.parent_id,
      text = _ref15.text,
      extraFields = (0, _objectWithoutProperties2["default"])(_ref15, _excluded);
    var _client$user2 = client.user,
      channel_mutes = _client$user2.channel_mutes,
      devices = _client$user2.devices,
      mutes = _client$user2.mutes,
      messageUser = (0, _objectWithoutProperties2["default"])(_client$user2, _excluded2);
    var preview = (0, _extends2["default"])({
      __html: text,
      attachments: attachments,
      created_at: new Date(),
      html: text,
      id: client.userID + "-" + (0, _utils.generateRandomId)(),
      mentioned_users: (mentioned_users == null ? void 0 : mentioned_users.map(function (userId) {
        return {
          id: userId
        };
      })) || [],
      parent_id: parent_id,
      reactions: [],
      status: _utils.MessageStatusTypes.SENDING,
      text: text,
      type: 'regular',
      user: (0, _extends2["default"])({
        id: client.userID
      }, messageUser)
    }, extraFields);
    if (preview.quoted_message_id) {
      var _quotedMessage = messages.find(function (message) {
        return message.id === preview.quoted_message_id;
      });
      preview.quoted_message = _quotedMessage;
    }
    return preview;
  };
  var uploadPendingAttachments = function () {
    var _ref16 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee12(message) {
      var _updatedMessage$attac;
      var updatedMessage, i, _updatedMessage$attac2, attachment, file, _file$name, filename, contentType, uploadResponse, response;
      return _regenerator["default"].wrap(function _callee12$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            updatedMessage = (0, _extends2["default"])({}, message);
            if (!((_updatedMessage$attac = updatedMessage.attachments) != null && _updatedMessage$attac.length)) {
              _context12.next = 40;
              break;
            }
            i = 0;
          case 3:
            if (!(i < ((_updatedMessage$attac2 = updatedMessage.attachments) == null ? void 0 : _updatedMessage$attac2.length))) {
              _context12.next = 40;
              break;
            }
            attachment = updatedMessage.attachments[i];
            file = attachment.originalFile;
            if (!(attachment.type === 'image' && file != null && file.uri && attachment.image_url && (0, _utils.isLocalUrl)(attachment.image_url))) {
              _context12.next = 22;
              break;
            }
            filename = (_file$name = file.name) != null ? _file$name : file.uri.replace(/^(file:\/\/|content:\/\/)/, '');
            contentType = (0, _mimeTypes.lookup)(filename) || 'multipart/form-data';
            if (!doImageUploadRequest) {
              _context12.next = 15;
              break;
            }
            _context12.next = 12;
            return doImageUploadRequest(file, channel);
          case 12:
            _context12.t0 = _context12.sent;
            _context12.next = 18;
            break;
          case 15:
            _context12.next = 17;
            return channel.sendImage(file.uri, filename, contentType);
          case 17:
            _context12.t0 = _context12.sent;
          case 18:
            uploadResponse = _context12.t0;
            attachment.image_url = uploadResponse.file;
            delete attachment.originalFile;
            dbApi.updateMessage({
              message: (0, _extends2["default"])({}, updatedMessage, {
                cid: channel.cid
              })
            });
          case 22:
            if (!((attachment.type === 'file' || attachment.type === 'audio' || attachment.type === 'video') && attachment.asset_url && (0, _utils.isLocalUrl)(attachment.asset_url) && file != null && file.uri)) {
              _context12.next = 37;
              break;
            }
            if (!doDocUploadRequest) {
              _context12.next = 29;
              break;
            }
            _context12.next = 26;
            return doDocUploadRequest(file, channel);
          case 26:
            _context12.t1 = _context12.sent;
            _context12.next = 32;
            break;
          case 29:
            _context12.next = 31;
            return channel.sendFile(file.uri, file.name, file.mimeType);
          case 31:
            _context12.t1 = _context12.sent;
          case 32:
            response = _context12.t1;
            attachment.asset_url = response.file;
            if (response.thumb_url) {
              attachment.thumb_url = response.thumb_url;
            }
            delete attachment.originalFile;
            dbApi.updateMessage({
              message: (0, _extends2["default"])({}, updatedMessage, {
                cid: channel.cid
              })
            });
          case 37:
            i++;
            _context12.next = 3;
            break;
          case 40:
            return _context12.abrupt("return", updatedMessage);
          case 41:
          case "end":
            return _context12.stop();
        }
      }, _callee12);
    }));
    return function uploadPendingAttachments(_x5) {
      return _ref16.apply(this, arguments);
    };
  }();
  var sendMessageRequest = function () {
    var _ref17 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee13(message, retrying) {
      var _updatedMessage, __html, attachments, created_at, deleted_at, html, id, latest_reactions, mentioned_users, own_reactions, parent_id, quoted_message, reaction_counts, reactions, status, text, type, updated_at, user, extraFields, mentionedUserIds, _messageData, messageResponse;
      return _regenerator["default"].wrap(function _callee13$(_context13) {
        while (1) switch (_context13.prev = _context13.next) {
          case 0:
            _context13.prev = 0;
            _context13.next = 3;
            return uploadPendingAttachments(message);
          case 3:
            _updatedMessage = _context13.sent;
            __html = _updatedMessage.__html, attachments = _updatedMessage.attachments, created_at = _updatedMessage.created_at, deleted_at = _updatedMessage.deleted_at, html = _updatedMessage.html, id = _updatedMessage.id, latest_reactions = _updatedMessage.latest_reactions, mentioned_users = _updatedMessage.mentioned_users, own_reactions = _updatedMessage.own_reactions, parent_id = _updatedMessage.parent_id, quoted_message = _updatedMessage.quoted_message, reaction_counts = _updatedMessage.reaction_counts, reactions = _updatedMessage.reactions, status = _updatedMessage.status, text = _updatedMessage.text, type = _updatedMessage.type, updated_at = _updatedMessage.updated_at, user = _updatedMessage.user, extraFields = (0, _objectWithoutProperties2["default"])(_updatedMessage, _excluded3);
            if (channel.id) {
              _context13.next = 7;
              break;
            }
            return _context13.abrupt("return");
          case 7:
            mentionedUserIds = (mentioned_users == null ? void 0 : mentioned_users.map(function (user) {
              return user.id;
            })) || [];
            _messageData = (0, _extends2["default"])({
              attachments: attachments,
              id: id,
              mentioned_users: mentionedUserIds,
              parent_id: parent_id,
              text: (0, _patchMessageTextCommand.patchMessageTextCommand)(text != null ? text : '', mentionedUserIds)
            }, extraFields);
            messageResponse = {};
            if (!doSendMessageRequest) {
              _context13.next = 16;
              break;
            }
            _context13.next = 13;
            return doSendMessageRequest((channel == null ? void 0 : channel.cid) || '', _messageData);
          case 13:
            messageResponse = _context13.sent;
            _context13.next = 20;
            break;
          case 16:
            if (!channel) {
              _context13.next = 20;
              break;
            }
            _context13.next = 19;
            return channel.sendMessage(_messageData);
          case 19:
            messageResponse = _context13.sent;
          case 20:
            if (messageResponse.message) {
              messageResponse.message.status = _utils.MessageStatusTypes.RECEIVED;
              if (enableOfflineSupport) {
                dbApi.updateMessage({
                  message: (0, _extends2["default"])({}, messageResponse.message, {
                    cid: channel.cid
                  })
                });
              }
              if (retrying) {
                replaceMessage(message, messageResponse.message);
              } else {
                updateMessage(messageResponse.message);
              }
            }
            _context13.next = 29;
            break;
          case 23:
            _context13.prev = 23;
            _context13.t0 = _context13["catch"](0);
            console.log(_context13.t0);
            message.status = _utils.MessageStatusTypes.FAILED;
            updateMessage((0, _extends2["default"])({}, message, {
              cid: channel.cid
            }));
            if (enableOfflineSupport) {
              dbApi.updateMessage({
                message: (0, _extends2["default"])({}, message, {
                  cid: channel.cid
                })
              });
            }
          case 29:
          case "end":
            return _context13.stop();
        }
      }, _callee13, null, [[0, 23]]);
    }));
    return function sendMessageRequest(_x6, _x7) {
      return _ref17.apply(this, arguments);
    };
  }();
  var sendMessage = function () {
    var _ref18 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee14(message) {
      var _channel$state;
      var messagePreview;
      return _regenerator["default"].wrap(function _callee14$(_context14) {
        while (1) switch (_context14.prev = _context14.next) {
          case 0:
            if (channel != null && (_channel$state = channel.state) != null && _channel$state.filterErrorMessages) {
              channel.state.filterErrorMessages();
            }
            messagePreview = createMessagePreview((0, _extends2["default"])({}, message, {
              attachments: message.attachments || []
            }));
            if (channel != null && channel.state.isUpToDate) {
              _context14.next = 5;
              break;
            }
            _context14.next = 5;
            return reloadChannel();
          case 5:
            updateMessage(messagePreview, {
              commands: [],
              messageInput: ''
            });
            if (enableOfflineSupport) {
              dbApi.upsertMessages({
                messages: [(0, _extends2["default"])({}, messagePreview, {
                  cid: channel.cid,
                  status: _utils.MessageStatusTypes.FAILED
                })]
              });
            }
            _context14.next = 9;
            return sendMessageRequest(messagePreview);
          case 9:
          case "end":
            return _context14.stop();
        }
      }, _callee14);
    }));
    return function sendMessage(_x8) {
      return _ref18.apply(this, arguments);
    };
  }();
  var retrySendMessage = function () {
    var _ref19 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee15(message) {
      var statusPendingMessage;
      return _regenerator["default"].wrap(function _callee15$(_context15) {
        while (1) switch (_context15.prev = _context15.next) {
          case 0:
            statusPendingMessage = (0, _extends2["default"])({}, message, {
              status: _utils.MessageStatusTypes.SENDING
            });
            updateMessage(statusPendingMessage);
            _context15.next = 4;
            return sendMessageRequest(statusPendingMessage, true);
          case 4:
          case "end":
            return _context15.stop();
        }
      }, _callee15);
    }));
    return function retrySendMessage(_x9) {
      return _ref19.apply(this, arguments);
    };
  }();
  var loadMoreFinished = (0, _react.useRef)((0, _debounce["default"])(function (updatedHasMore, newMessages) {
    setLoadingMore(false);
    setError(false);
    setHasMore(updatedHasMore);
    setMessages(newMessages);
  }, defaultDebounceInterval, debounceOptions)).current;
  var loadMore = function () {
    var _ref20 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee16() {
      var limit,
        oldestMessage,
        oldestID,
        queryResponse,
        updatedHasMore,
        _args16 = arguments;
      return _regenerator["default"].wrap(function _callee16$(_context16) {
        while (1) switch (_context16.prev = _context16.next) {
          case 0:
            limit = _args16.length > 0 && _args16[0] !== undefined ? _args16[0] : 20;
            if (!(loadingMore || hasMore === false)) {
              _context16.next = 3;
              break;
            }
            return _context16.abrupt("return");
          case 3:
            setLoadingMore(true);
            if (messages.length) {
              _context16.next = 6;
              break;
            }
            return _context16.abrupt("return", setLoadingMore(false));
          case 6:
            oldestMessage = messages && messages[0];
            if (!(oldestMessage && oldestMessage.status !== _utils.MessageStatusTypes.RECEIVED)) {
              _context16.next = 9;
              break;
            }
            return _context16.abrupt("return", setLoadingMore(false));
          case 9:
            oldestID = oldestMessage && oldestMessage.id;
            _context16.prev = 10;
            if (!channel) {
              _context16.next = 17;
              break;
            }
            _context16.next = 14;
            return channel.query({
              messages: {
                id_lt: oldestID,
                limit: limit
              }
            });
          case 14:
            queryResponse = _context16.sent;
            updatedHasMore = queryResponse.messages.length === limit;
            loadMoreFinished(updatedHasMore, channel.state.messages);
          case 17:
            _context16.next = 24;
            break;
          case 19:
            _context16.prev = 19;
            _context16.t0 = _context16["catch"](10);
            if (_context16.t0 instanceof Error) {
              setError(_context16.t0);
            } else {
              setError(true);
            }
            setLoadingMore(false);
            throw _context16.t0;
          case 24:
          case "end":
            return _context16.stop();
        }
      }, _callee16, null, [[10, 19]]);
    }));
    return function loadMore() {
      return _ref20.apply(this, arguments);
    };
  }();
  var loadMoreRecent = function () {
    var _ref21 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee17() {
      var limit,
        recentMessage,
        state,
        _args17 = arguments;
      return _regenerator["default"].wrap(function _callee17$(_context17) {
        while (1) switch (_context17.prev = _context17.next) {
          case 0:
            limit = _args17.length > 0 && _args17[0] !== undefined ? _args17[0] : 5;
            if (!hasNoMoreRecentMessagesToLoad) {
              _context17.next = 3;
              break;
            }
            return _context17.abrupt("return");
          case 3:
            setLoadingMoreRecent(true);
            recentMessage = messages[messages.length - 1];
            if (!((recentMessage == null ? void 0 : recentMessage.status) !== _utils.MessageStatusTypes.RECEIVED)) {
              _context17.next = 8;
              break;
            }
            setLoadingMoreRecent(false);
            return _context17.abrupt("return");
          case 8:
            _context17.prev = 8;
            if (!channel) {
              _context17.next = 15;
              break;
            }
            _context17.next = 12;
            return channel.query({
              messages: {
                id_gte: recentMessage.id,
                limit: limit
              },
              watch: true
            });
          case 12:
            state = _context17.sent;
            setHasNoMoreRecentMessagesToLoad(state.messages.length < limit);
            loadMoreRecentFinished(channel.state.messages);
          case 15:
            _context17.next = 23;
            break;
          case 17:
            _context17.prev = 17;
            _context17.t0 = _context17["catch"](8);
            console.warn('Message pagination request failed with error', _context17.t0);
            if (_context17.t0 instanceof Error) {
              setError(_context17.t0);
            } else {
              setError(true);
            }
            setLoadingMoreRecent(false);
            throw _context17.t0;
          case 23:
          case "end":
            return _context17.stop();
        }
      }, _callee17, null, [[8, 17]]);
    }));
    return function loadMoreRecent() {
      return _ref21.apply(this, arguments);
    };
  }();
  var loadMoreRecentFinished = (0, _react.useRef)((0, _debounce["default"])(function (newMessages) {
    setLoadingMoreRecent(false);
    setMessages(newMessages);
    setError(false);
  }, defaultDebounceInterval, debounceOptions)).current;
  var editMessage = function editMessage(updatedMessage) {
    return doUpdateMessageRequest ? doUpdateMessageRequest((channel == null ? void 0 : channel.cid) || '', updatedMessage) : client.updateMessage(updatedMessage);
  };
  var setEditingState = function setEditingState(message) {
    setEditing(message);
  };
  var setQuotedMessageState = function setQuotedMessageState(message) {
    setQuotedMessage(message);
  };
  var clearEditingState = function clearEditingState() {
    return setEditing(false);
  };
  var clearQuotedMessageState = function clearQuotedMessageState() {
    return setQuotedMessage(false);
  };
  var removeMessage = function removeMessage(message) {
    if (channel) {
      channel.state.removeMessage(message);
      setMessages(channel.state.messages);
      if (thread) {
        setThreadMessages(channel.state.threads[thread.id] || []);
      }
    }
    if (enableOfflineSupport) {
      dbApi.deleteMessage({
        id: message.id
      });
    }
  };
  var sendReaction = function () {
    var _ref22 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee18(type, messageId) {
      var payload;
      return _regenerator["default"].wrap(function _callee18$(_context18) {
        while (1) switch (_context18.prev = _context18.next) {
          case 0:
            if (!(!(channel != null && channel.id) || !client.user)) {
              _context18.next = 2;
              break;
            }
            throw new Error('Channel has not been initialized');
          case 2:
            payload = [messageId, {
              type: type
            }, {
              enforce_unique: enforceUniqueReaction
            }];
            if (enableOfflineSupport) {
              _context18.next = 7;
              break;
            }
            _context18.next = 6;
            return channel.sendReaction.apply(channel, payload);
          case 6:
            return _context18.abrupt("return");
          case 7:
            (0, _addReactionToLocalState.addReactionToLocalState)({
              channel: channel,
              enforceUniqueReaction: enforceUniqueReaction,
              messageId: messageId,
              reactionType: type,
              user: client.user
            });
            setMessages(channel.state.messages);
            _context18.next = 11;
            return _DBSyncManager.DBSyncManager.queueTask({
              client: client,
              task: {
                channelId: channel.id,
                channelType: channel.type,
                messageId: messageId,
                payload: payload,
                type: 'send-reaction'
              }
            });
          case 11:
          case "end":
            return _context18.stop();
        }
      }, _callee18);
    }));
    return function sendReaction(_x10, _x11) {
      return _ref22.apply(this, arguments);
    };
  }();
  var deleteMessage = function () {
    var _ref23 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee19(message) {
      var _data;
      return _regenerator["default"].wrap(function _callee19$(_context19) {
        while (1) switch (_context19.prev = _context19.next) {
          case 0:
            if (channel.id) {
              _context19.next = 2;
              break;
            }
            throw new Error('Channel has not been initialized yet');
          case 2:
            if (enableOfflineSupport) {
              _context19.next = 9;
              break;
            }
            if (!(message.status === _utils.MessageStatusTypes.FAILED)) {
              _context19.next = 6;
              break;
            }
            removeMessage(message);
            return _context19.abrupt("return");
          case 6:
            _context19.next = 8;
            return client.deleteMessage(message.id);
          case 8:
            return _context19.abrupt("return");
          case 9:
            if (!(message.status === _utils.MessageStatusTypes.FAILED)) {
              _context19.next = 14;
              break;
            }
            _DBSyncManager.DBSyncManager.dropPendingTasks({
              messageId: message.id
            });
            removeMessage(message);
            _context19.next = 19;
            break;
          case 14:
            updateMessage((0, _extends2["default"])({}, message, {
              cid: channel.cid,
              deleted_at: new Date().toISOString(),
              type: 'deleted'
            }));
            _context19.next = 17;
            return _DBSyncManager.DBSyncManager.queueTask({
              client: client,
              task: {
                channelId: channel.id,
                channelType: channel.type,
                messageId: message.id,
                payload: [message.id],
                type: 'delete-message'
              }
            });
          case 17:
            _data = _context19.sent;
            if (_data != null && _data.message) {
              updateMessage((0, _extends2["default"])({}, _data.message));
            }
          case 19:
          case "end":
            return _context19.stop();
        }
      }, _callee19);
    }));
    return function deleteMessage(_x12) {
      return _ref23.apply(this, arguments);
    };
  }();
  var deleteReaction = function () {
    var _ref24 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee20(type, messageId) {
      var payload;
      return _regenerator["default"].wrap(function _callee20$(_context20) {
        while (1) switch (_context20.prev = _context20.next) {
          case 0:
            if (!(!(channel != null && channel.id) || !client.user)) {
              _context20.next = 2;
              break;
            }
            throw new Error('Channel has not been initialized');
          case 2:
            payload = [messageId, type];
            if (enableOfflineSupport) {
              _context20.next = 7;
              break;
            }
            _context20.next = 6;
            return channel.deleteReaction.apply(channel, payload);
          case 6:
            return _context20.abrupt("return");
          case 7:
            (0, _removeReactionFromLocalState.removeReactionFromLocalState)({
              channel: channel,
              messageId: messageId,
              reactionType: type,
              user: client.user
            });
            setMessages(channel.state.messages);
            _context20.next = 11;
            return _DBSyncManager.DBSyncManager.queueTask({
              client: client,
              task: {
                channelId: channel.id,
                channelType: channel.type,
                messageId: messageId,
                payload: payload,
                type: 'delete-reaction'
              }
            });
          case 11:
          case "end":
            return _context20.stop();
        }
      }, _callee20);
    }));
    return function deleteReaction(_x13, _x14) {
      return _ref24.apply(this, arguments);
    };
  }();
  var openThread = function openThread(message) {
    var _channel$state2;
    var newThreadMessages = message != null && message.id ? (channel == null ? void 0 : (_channel$state2 = channel.state) == null ? void 0 : _channel$state2.threads[message.id]) || [] : [];
    setThread(message);
    setThreadMessages(newThreadMessages);
  };
  var closeThread = (0, _react.useCallback)(function () {
    setThread(null);
    setThreadMessages([]);
  }, [setThread, setThreadMessages]);
  var loadMoreThreadFinished = (0, _react.useRef)((0, _debounce["default"])(function (newThreadHasMore, updatedThreadMessages) {
    setThreadHasMore(newThreadHasMore);
    setThreadLoadingMore(false);
    setThreadMessages(updatedThreadMessages);
  }, defaultDebounceInterval, debounceOptions)).current;
  var loadMoreThread = function () {
    var _ref25 = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee21() {
      var _threadMessages$, parentID, oldestMessageID, limit, queryResponse, updatedHasMore, updatedThreadMessages;
      return _regenerator["default"].wrap(function _callee21$(_context21) {
        while (1) switch (_context21.prev = _context21.next) {
          case 0:
            if (!(threadLoadingMore || !(thread != null && thread.id))) {
              _context21.next = 2;
              break;
            }
            return _context21.abrupt("return");
          case 2:
            setThreadLoadingMore(true);
            _context21.prev = 3;
            if (!channel) {
              _context21.next = 15;
              break;
            }
            parentID = thread.id;
            channel.state.threads[parentID] = threadMessages;
            oldestMessageID = threadMessages == null ? void 0 : (_threadMessages$ = threadMessages[0]) == null ? void 0 : _threadMessages$.id;
            limit = 50;
            _context21.next = 11;
            return channel.getReplies(parentID, {
              id_lt: oldestMessageID,
              limit: limit
            });
          case 11:
            queryResponse = _context21.sent;
            updatedHasMore = queryResponse.messages.length === limit;
            updatedThreadMessages = channel.state.threads[parentID] || [];
            loadMoreThreadFinished(updatedHasMore, updatedThreadMessages);
          case 15:
            _context21.next = 23;
            break;
          case 17:
            _context21.prev = 17;
            _context21.t0 = _context21["catch"](3);
            console.warn('Message pagination request failed with error', _context21.t0);
            if (_context21.t0 instanceof Error) {
              setError(_context21.t0);
            } else {
              setError(true);
            }
            setThreadLoadingMore(false);
            throw _context21.t0;
          case 23:
          case "end":
            return _context21.stop();
        }
      }, _callee21, null, [[3, 17]]);
    }));
    return function loadMoreThread() {
      return _ref25.apply(this, arguments);
    };
  }();
  var ownCapabilitiesContext = (0, _useCreateOwnCapabilitiesContext.useCreateOwnCapabilitiesContext)({
    channel: channel,
    overrideCapabilities: overrideOwnCapabilities
  });
  var channelContext = (0, _useCreateChannelContext.useCreateChannelContext)({
    channel: channel,
    disabled: !!(channel != null && (_channel$data = channel.data) != null && _channel$data.frozen) && disableIfFrozenChannel,
    EmptyStateIndicator: EmptyStateIndicator,
    enableMessageGroupingByUser: enableMessageGroupingByUser,
    enforceUniqueReaction: enforceUniqueReaction,
    error: error,
    giphyEnabled: giphyEnabled != null ? giphyEnabled : !!((_ref26 = (clientChannelConfig == null ? void 0 : clientChannelConfig.commands) || []) != null && _ref26.some(function (command) {
      return command.name === 'giphy';
    })),
    hideDateSeparators: hideDateSeparators,
    hideStickyDateHeader: hideStickyDateHeader,
    isAdmin: isAdmin,
    isChannelActive: shouldSyncChannel,
    isModerator: isModerator,
    isOwner: isOwner,
    lastRead: lastRead,
    loadChannelAroundMessage: loadChannelAroundMessage,
    loadChannelAtMessage: loadChannelAtMessage,
    loading: loading,
    LoadingIndicator: LoadingIndicator,
    markRead: markRead,
    maxTimeBetweenGroupedMessages: maxTimeBetweenGroupedMessages,
    members: members,
    NetworkDownIndicator: NetworkDownIndicator,
    read: read,
    reloadChannel: reloadChannel,
    scrollToFirstUnreadThreshold: scrollToFirstUnreadThreshold,
    setLastRead: setLastRead,
    setTargetedMessage: setTargetedMessage,
    StickyHeader: StickyHeader,
    targetedMessage: targetedMessage,
    threadList: threadList,
    watcherCount: watcherCount,
    watchers: watchers
  });
  var inputMessageInputContext = (0, _useCreateInputMessageInputContext.useCreateInputMessageInputContext)({
    additionalTextInputProps: additionalTextInputProps,
    AttachButton: AttachButton,
    autoCompleteSuggestionsLimit: autoCompleteSuggestionsLimit,
    autoCompleteTriggerSettings: autoCompleteTriggerSettings,
    channelId: channelId,
    clearEditingState: clearEditingState,
    clearQuotedMessageState: clearQuotedMessageState,
    CommandsButton: CommandsButton,
    compressImageQuality: compressImageQuality,
    CooldownTimer: CooldownTimer,
    doDocUploadRequest: doDocUploadRequest,
    doImageUploadRequest: doImageUploadRequest,
    editing: editing,
    editMessage: editMessage,
    FileUploadPreview: FileUploadPreview,
    hasCommands: hasCommands,
    hasFilePicker: hasFilePicker,
    hasImagePicker: hasImagePicker,
    ImageUploadPreview: ImageUploadPreview,
    initialValue: initialValue,
    Input: Input,
    InputButtons: InputButtons,
    InputEditingStateHeader: InputEditingStateHeader,
    InputGiphySearch: InputGiphySearch,
    InputReplyStateHeader: InputReplyStateHeader,
    maxMessageLength: (_ref27 = maxMessageLengthProp != null ? maxMessageLengthProp : clientChannelConfig == null ? void 0 : clientChannelConfig.max_message_length) != null ? _ref27 : undefined,
    maxNumberOfFiles: maxNumberOfFiles,
    mentionAllAppUsersEnabled: mentionAllAppUsersEnabled,
    mentionAllAppUsersQuery: mentionAllAppUsersQuery,
    MoreOptionsButton: MoreOptionsButton,
    numberOfLines: numberOfLines,
    onChangeText: onChangeText,
    quotedMessage: quotedMessage,
    SendButton: SendButton,
    sendImageAsync: sendImageAsync,
    sendMessage: sendMessage,
    SendMessageDisallowedIndicator: SendMessageDisallowedIndicator,
    setInputRef: setInputRef,
    setQuotedMessageState: setQuotedMessageState,
    ShowThreadMessageInChannelButton: ShowThreadMessageInChannelButton,
    UploadProgressIndicator: UploadProgressIndicator
  });
  var messageListContext = (0, _useCreatePaginatedMessageListContext.useCreatePaginatedMessageListContext)({
    channelId: channelId,
    hasMore: hasMore,
    hasNoMoreRecentMessagesToLoad: hasNoMoreRecentMessagesToLoad,
    loadingMore: loadingMoreProp !== undefined ? loadingMoreProp : loadingMore,
    loadingMoreRecent: loadingMoreRecentProp !== undefined ? loadingMoreRecentProp : loadingMoreRecent,
    loadMore: loadMore,
    loadMoreRecent: loadMoreRecent,
    messages: messages,
    setLoadingMore: setLoadingMore,
    setLoadingMoreRecent: setLoadingMoreRecent
  });
  var messagesContext = (0, _useCreateMessagesContext.useCreateMessagesContext)({
    additionalTouchableProps: additionalTouchableProps,
    Attachment: Attachment,
    AttachmentActions: AttachmentActions,
    AudioAttachment: AudioAttachment,
    Card: Card,
    CardCover: CardCover,
    CardFooter: CardFooter,
    CardHeader: CardHeader,
    channelId: channelId,
    DateHeader: DateHeader,
    deletedMessagesVisibilityType: deletedMessagesVisibilityType,
    deleteMessage: deleteMessage,
    deleteReaction: deleteReaction,
    disableTypingIndicator: disableTypingIndicator,
    dismissKeyboardOnMessageTouch: dismissKeyboardOnMessageTouch,
    enableMessageGroupingByUser: enableMessageGroupingByUser,
    FileAttachment: FileAttachment,
    FileAttachmentGroup: FileAttachmentGroup,
    FileAttachmentIcon: FileAttachmentIcon,
    FlatList: FlatList,
    forceAlignMessages: forceAlignMessages,
    formatDate: formatDate,
    Gallery: Gallery,
    getMessagesGroupStyles: getMessagesGroupStyles,
    Giphy: Giphy,
    giphyVersion: giphyVersion,
    handleBlock: handleBlock,
    handleCopy: handleCopy,
    handleDelete: handleDelete,
    handleEdit: handleEdit,
    handleFlag: handleFlag,
    handleMute: handleMute,
    handlePinMessage: handlePinMessage,
    handleQuotedReply: handleQuotedReply,
    handleReaction: handleReaction,
    handleRetry: handleRetry,
    handleThreadReply: handleThreadReply,
    ImageLoadingFailedIndicator: ImageLoadingFailedIndicator,
    ImageLoadingIndicator: ImageLoadingIndicator,
    initialScrollToFirstUnreadMessage: !messageId && initialScrollToFirstUnreadMessage,
    InlineDateSeparator: InlineDateSeparator,
    InlineUnreadIndicator: InlineUnreadIndicator,
    isAttachmentEqual: isAttachmentEqual,
    legacyImageViewerSwipeBehaviour: legacyImageViewerSwipeBehaviour,
    markdownRules: markdownRules,
    Message: Message,
    messageActions: messageActions,
    MessageAvatar: MessageAvatar,
    MessageContent: MessageContent,
    messageContentOrder: messageContentOrder,
    MessageDeleted: MessageDeleted,
    MessageFooter: MessageFooter,
    MessageHeader: MessageHeader,
    MessageList: MessageList,
    MessagePinnedHeader: MessagePinnedHeader,
    MessageReplies: MessageReplies,
    MessageRepliesAvatars: MessageRepliesAvatars,
    MessageSimple: MessageSimple,
    MessageStatus: MessageStatus,
    MessageSystem: MessageSystem,
    MessageText: MessageText,
    myMessageTheme: myMessageTheme,
    onLongPressMessage: onLongPressMessage,
    onPressInMessage: onPressInMessage,
    onPressMessage: onPressMessage,
    OverlayReactionList: OverlayReactionList,
    ReactionList: ReactionList,
    removeMessage: removeMessage,
    Reply: Reply,
    retrySendMessage: retrySendMessage,
    ScrollToBottomButton: ScrollToBottomButton,
    selectReaction: selectReaction,
    sendReaction: sendReaction,
    setEditingState: setEditingState,
    setQuotedMessageState: setQuotedMessageState,
    supportedReactions: supportedReactions,
    targetedMessage: targetedMessage,
    TypingIndicator: TypingIndicator,
    TypingIndicatorContainer: TypingIndicatorContainer,
    updateMessage: updateMessage,
    UrlPreview: UrlPreview,
    VideoThumbnail: VideoThumbnail
  });
  var suggestionsContext = {
    AutoCompleteSuggestionHeader: AutoCompleteSuggestionHeader,
    AutoCompleteSuggestionItem: AutoCompleteSuggestionItem,
    AutoCompleteSuggestionList: AutoCompleteSuggestionList
  };
  var threadContext = (0, _useCreateThreadContext.useCreateThreadContext)({
    allowThreadMessagesInChannel: allowThreadMessagesInChannel,
    closeThread: closeThread,
    loadMoreThread: loadMoreThread,
    openThread: openThread,
    reloadThread: reloadThread,
    setThreadLoadingMore: setThreadLoadingMore,
    thread: thread,
    threadHasMore: threadHasMore,
    threadLoadingMore: threadLoadingMore,
    threadMessages: threadMessages
  });
  var typingContext = (0, _useCreateTypingContext.useCreateTypingContext)({
    typing: typing
  });
  if (deleted) return null;
  if (!channel || error && messages.length === 0) {
    return _react["default"].createElement(LoadingErrorIndicator, {
      error: error,
      listType: "message",
      retry: reloadChannel,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 2025,
        columnNumber: 12
      }
    });
  }
  if (!(channel != null && channel.cid) || !channel.watch) {
    return _react["default"].createElement(_reactNative.Text, {
      style: [styles.selectChannel, {
        color: black
      }, selectChannel],
      testID: "no-channel",
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 2030,
        columnNumber: 7
      }
    }, t('Please select a channel first'));
  }
  return _react["default"].createElement(KeyboardCompatibleView, (0, _extends2["default"])({
    behavior: keyboardBehavior,
    enabled: !disableKeyboardCompatibleView,
    keyboardVerticalOffset: keyboardVerticalOffset
  }, additionalKeyboardAvoidingViewProps, {
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 2037,
      columnNumber: 5
    }
  }), _react["default"].createElement(_ChannelContext.ChannelProvider, {
    value: channelContext,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 2043,
      columnNumber: 7
    }
  }, _react["default"].createElement(_OwnCapabilitiesContext.OwnCapabilitiesProvider, {
    value: ownCapabilitiesContext,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 2044,
      columnNumber: 9
    }
  }, _react["default"].createElement(_TypingContext.TypingProvider, {
    value: typingContext,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 2045,
      columnNumber: 11
    }
  }, _react["default"].createElement(_PaginatedMessageListContext.PaginatedMessageListProvider, {
    value: messageListContext,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 2046,
      columnNumber: 13
    }
  }, _react["default"].createElement(_MessagesContext.MessagesProvider, {
    value: messagesContext,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 2047,
      columnNumber: 15
    }
  }, _react["default"].createElement(_ThreadContext.ThreadProvider, {
    value: threadContext,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 2048,
      columnNumber: 17
    }
  }, _react["default"].createElement(_SuggestionsContext.SuggestionsProvider, {
    value: suggestionsContext,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 2049,
      columnNumber: 19
    }
  }, _react["default"].createElement(_MessageInputContext.MessageInputProvider, {
    value: inputMessageInputContext,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 2050,
      columnNumber: 21
    }
  }, _react["default"].createElement(_reactNative.View, {
    style: {
      height: '100%'
    },
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 2051,
      columnNumber: 23
    }
  }, children))))))))));
};
var Channel = function Channel(props) {
  var _props$thread, _props$thread2;
  var _useChatContext = (0, _ChatContext.useChatContext)(),
    client = _useChatContext.client,
    enableOfflineSupport = _useChatContext.enableOfflineSupport;
  var _useTranslationContex = (0, _TranslationContext.useTranslationContext)(),
    t = _useTranslationContex.t;
  var shouldSyncChannel = (_props$thread = props.thread) != null && _props$thread.id ? !!props.threadList : true;
  var _useChannelState = (0, _useChannelState2.useChannelState)(props.channel, props.threadList ? (_props$thread2 = props.thread) == null ? void 0 : _props$thread2.id : undefined),
    members = _useChannelState.members,
    messages = _useChannelState.messages,
    read = _useChannelState.read,
    setMembers = _useChannelState.setMembers,
    setMessages = _useChannelState.setMessages,
    setRead = _useChannelState.setRead,
    setThreadMessages = _useChannelState.setThreadMessages,
    setTyping = _useChannelState.setTyping,
    setWatcherCount = _useChannelState.setWatcherCount,
    setWatchers = _useChannelState.setWatchers,
    threadMessages = _useChannelState.threadMessages,
    typing = _useChannelState.typing,
    watcherCount = _useChannelState.watcherCount,
    watchers = _useChannelState.watchers;
  return _react["default"].createElement(ChannelWithContext, (0, _extends2["default"])({
    client: client,
    enableOfflineSupport: enableOfflineSupport,
    t: t
  }, props, {
    shouldSyncChannel: shouldSyncChannel,
    members: members,
    messages: props.messages || messages,
    read: read,
    setMembers: setMembers,
    setMessages: setMessages,
    setRead: setRead,
    setThreadMessages: setThreadMessages,
    setTyping: setTyping,
    setWatcherCount: setWatcherCount,
    setWatchers: setWatchers,
    threadMessages: threadMessages,
    typing: typing,
    watcherCount: watcherCount,
    watchers: watchers,
    __self: _this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 2108,
      columnNumber: 5
    }
  }));
};
exports.Channel = Channel;
//# sourceMappingURL=Channel.js.map