{"version":3,"names":["_react","require","_ActiveChannelsRefContext","_ChatContext","_useIsMountedRef","_getChannelsForFilterSort","_date","_DBSyncManager","_utils","waitSeconds","seconds","Promise","resolve","setTimeout","ONE_SECOND_IN_MS","DEFAULT_OPTIONS","message_limit","MAX_NUMBER_OF_RETRIES","RETRY_INTERVAL_IN_MS","usePaginatedChannels","_ref","enableOfflineSupport","_ref$filters","filters","_ref$options","options","setForceUpdate","_ref$sort","sort","_useState","useState","_useState2","_slicedToArray2","channels","setChannels","_useState3","undefined","_useState4","error","setError","_useState5","_useState6","staticChannelsActive","setStaticChannelsActive","_useState7","_useState8","activeQueryType","setActiveQueryType","_useState9","_useState10","hasNextPage","setHasNextPage","activeChannels","useActiveChannelsRefContext","isMountedRef","useIsMountedRef","_useChatContext","useChatContext","client","filtersRef","useRef","sortRef","activeRequestId","isQueryingRef","lastRefresh","Date","now","queryChannels","_ref2","_asyncToGenerator2","_regenerator","mark","_callee","_options$limit","queryType","retryCount","hasUpdatedData","isQueryStale","currentRequestId","newOptions","channelQueryResponse","newChannels","_args","arguments","wrap","_callee$","_context","prev","next","length","current","abrupt","JSON","stringify","some","Boolean","_extends2","limit","MAX_QUERY_CHANNELS_LIMIT","offset","skipInitialization","sent","concat","_toConsumableArray2","map","c","existingChannel","cid","t0","console","warn","Error","stop","apply","refreshList","_ref3","_callee2","_callee2$","_context2","reloadList","filterStr","useMemo","sortStr","useEffect","loadOfflineChannels","_client$user","user","id","channelsFromDB","getChannelsForFilterSort","currentUserId","offlineChannels","hydrateActiveChannels","offlineMode","e","listener","DBSyncManager","onSyncStatusChange","syncStatus","dbSyncStatus","getSyncStatus","on","_ref4","_callee3","event","_callee3$","_context3","online","u","_x","_listener","unsubscribe","loadingChannels","loadingNextPage","loadNextPage","refreshing","exports"],"sources":["usePaginatedChannels.ts"],"sourcesContent":["import { useEffect, useMemo, useRef, useState } from 'react';\n\nimport type { Channel, ChannelFilters, ChannelOptions, ChannelSort } from 'stream-chat';\n\nimport { useActiveChannelsRefContext } from '../../../contexts/activeChannelsRefContext/ActiveChannelsRefContext';\nimport { useChatContext } from '../../../contexts/chatContext/ChatContext';\nimport { useIsMountedRef } from '../../../hooks/useIsMountedRef';\n\nimport { getChannelsForFilterSort } from '../../../store/apis/getChannelsForFilterSort';\nimport type { DefaultStreamChatGenerics } from '../../../types/types';\nimport { ONE_SECOND_IN_MS } from '../../../utils/date';\nimport { DBSyncManager } from '../../../utils/DBSyncManager';\nimport { MAX_QUERY_CHANNELS_LIMIT } from '../utils';\n\nconst waitSeconds = (seconds: number) =>\n  new Promise((resolve) => {\n    setTimeout(resolve, seconds * ONE_SECOND_IN_MS);\n  });\n\ntype Parameters<StreamChatGenerics extends DefaultStreamChatGenerics = DefaultStreamChatGenerics> =\n  {\n    enableOfflineSupport: boolean;\n    filters: ChannelFilters<StreamChatGenerics>;\n    options: ChannelOptions;\n    setForceUpdate: React.Dispatch<React.SetStateAction<number>>;\n    sort: ChannelSort<StreamChatGenerics>;\n  };\n\nconst DEFAULT_OPTIONS = {\n  message_limit: 10,\n};\n\nconst MAX_NUMBER_OF_RETRIES = 3;\nconst RETRY_INTERVAL_IN_MS = 5000;\n\ntype QueryType = 'queryLocalDB' | 'reload' | 'refresh' | 'loadChannels';\n\nexport type QueryChannels = (queryType?: QueryType, retryCount?: number) => Promise<void>;\n\nexport const usePaginatedChannels = <\n  StreamChatGenerics extends DefaultStreamChatGenerics = DefaultStreamChatGenerics,\n>({\n  enableOfflineSupport,\n  filters = {},\n  options = DEFAULT_OPTIONS,\n  setForceUpdate,\n  sort = {},\n}: Parameters<StreamChatGenerics>) => {\n  const [channels, setChannels] = useState<Channel<StreamChatGenerics>[] | null>(null);\n  const [error, setError] = useState<Error | undefined>(undefined);\n  const [staticChannelsActive, setStaticChannelsActive] = useState<boolean>(false);\n  const [activeQueryType, setActiveQueryType] = useState<QueryType | null>('queryLocalDB');\n  const [hasNextPage, setHasNextPage] = useState<boolean>(false);\n  const activeChannels = useActiveChannelsRefContext();\n  const isMountedRef = useIsMountedRef();\n  const { client } = useChatContext<StreamChatGenerics>();\n\n  const filtersRef = useRef<typeof filters | null>(null);\n  const sortRef = useRef<typeof sort | null>(null);\n  const activeRequestId = useRef<number>(0);\n  const isQueryingRef = useRef(false);\n  const lastRefresh = useRef(Date.now());\n\n  const queryChannels: QueryChannels = async (\n    queryType: QueryType = 'loadChannels',\n    retryCount = 0,\n  ): Promise<void> => {\n    if (!client || !isMountedRef.current) return;\n\n    const hasUpdatedData =\n      queryType === 'loadChannels' ||\n      queryType === 'refresh' ||\n      [\n        JSON.stringify(filtersRef.current) !== JSON.stringify(filters),\n        JSON.stringify(sortRef.current) !== JSON.stringify(sort),\n      ].some(Boolean);\n\n    const isQueryStale = () => !isMountedRef || activeRequestId.current !== currentRequestId;\n\n    /**\n     * We don't need to make another call to query channels if we don't\n     * have new data for the query to include\n     * */\n    if (!hasUpdatedData) {\n      if (activeQueryType === null) return;\n    }\n\n    filtersRef.current = filters;\n    sortRef.current = sort;\n    isQueryingRef.current = true;\n    setError(undefined);\n    activeRequestId.current++;\n    const currentRequestId = activeRequestId.current;\n    setActiveQueryType(queryType);\n\n    const newOptions = {\n      limit: options?.limit ?? MAX_QUERY_CHANNELS_LIMIT,\n      offset:\n        queryType === 'loadChannels' && !staticChannelsActive && channels ? channels.length : 0,\n      ...options,\n    };\n\n    try {\n      /**\n       * We skipInitialization here for handling race condition between ChannelList, Channel (and Thread)\n       * when they all (may) update the channel state at the same time (when connection state recovers)\n       * TODO: if we move the channel state to a single context and share it between ChannelList, Channel and Thread we can remove this\n       */\n      const channelQueryResponse = await client.queryChannels(filters, sort, newOptions, {\n        skipInitialization: enableOfflineSupport ? undefined : activeChannels.current,\n      });\n      if (isQueryStale() || !isMountedRef.current) {\n        return;\n      }\n\n      const newChannels =\n        queryType === 'loadChannels' && !staticChannelsActive && channels\n          ? [...channels, ...channelQueryResponse]\n          : channelQueryResponse.map((c) => {\n              const existingChannel = client.activeChannels[c.cid];\n              if (existingChannel) {\n                return existingChannel;\n              }\n\n              return c;\n            });\n\n      setChannels(newChannels);\n      setStaticChannelsActive(false);\n      setHasNextPage(channelQueryResponse.length >= newOptions.limit);\n      isQueryingRef.current = false;\n    } catch (err: unknown) {\n      isQueryingRef.current = false;\n      await waitSeconds(2);\n\n      if (isQueryStale()) {\n        return;\n      }\n\n      // querying.current check is needed in order to make sure the next query call doesnt flick an error\n      // state and then succeed (reconnect case)\n      if (retryCount === MAX_NUMBER_OF_RETRIES && !isQueryingRef.current) {\n        setActiveQueryType(null);\n        console.warn(err);\n\n        setError(\n          new Error(\n            `Maximum number of retries reached in queryChannels. Last error message is: ${err}`,\n          ),\n        );\n        return;\n      }\n\n      return queryChannels(queryType, retryCount + 1);\n    }\n\n    setActiveQueryType(null);\n  };\n\n  const refreshList = async () => {\n    const now = Date.now();\n    // Only allow pull-to-refresh 5 seconds after last successful refresh.\n    if (now - lastRefresh.current < RETRY_INTERVAL_IN_MS && error === undefined) {\n      return;\n    }\n\n    lastRefresh.current = Date.now();\n    await queryChannels('refresh');\n  };\n\n  const reloadList = () => queryChannels('reload');\n\n  /**\n   * Equality check using stringified filters/sort ensure that we don't make un-necessary queryChannels api calls\n   * for the scenario:\n   *\n   * <ChannelList\n   *    filters={{\n   *      members: { $in: ['vishal'] }\n   *    }}\n   *    ...\n   * />\n   *\n   * Here we have passed filters as inline object, which means on every re-render of\n   * parent component, ChannelList will receive new object reference (even though value is same), which\n   * in return will trigger useEffect. To avoid this, we can add a value check.\n   */\n  const filterStr = useMemo(() => JSON.stringify(filters), [filters]);\n  const sortStr = useMemo(() => JSON.stringify(sort), [sort]);\n\n  useEffect(() => {\n    const loadOfflineChannels = () => {\n      if (!client?.user?.id) return;\n\n      try {\n        const channelsFromDB = getChannelsForFilterSort({\n          currentUserId: client.user.id,\n          filters,\n          sort,\n        });\n\n        if (channelsFromDB) {\n          const offlineChannels = client.hydrateActiveChannels(channelsFromDB, {\n            offlineMode: true,\n            skipInitialization: [], // passing empty array will clear out the existing messages from channel state, this removes the possibility of duplicate messages\n          });\n\n          setChannels(offlineChannels);\n          setStaticChannelsActive(true);\n        }\n      } catch (e) {\n        console.warn('Failed to get channels from database: ', e);\n      }\n\n      setActiveQueryType(null);\n    };\n\n    let listener: ReturnType<typeof DBSyncManager.onSyncStatusChange>;\n    if (enableOfflineSupport) {\n      // Any time DB is synced, we need to update the UI with local DB channels first,\n      // and then call queryChannels to ensure any new channels are added to UI.\n      listener = DBSyncManager.onSyncStatusChange((syncStatus) => {\n        if (syncStatus) {\n          loadOfflineChannels();\n          reloadList();\n        }\n      });\n      // On start, load the channels from local db.\n      loadOfflineChannels();\n\n      // If db is already synced (sync api and pending api calls), then\n      // right away call queryChannels.\n      const dbSyncStatus = DBSyncManager.getSyncStatus();\n      if (dbSyncStatus) {\n        reloadList();\n      }\n    } else {\n      listener = client.on('connection.changed', async (event) => {\n        if (event.online) {\n          await refreshList();\n          setForceUpdate((u) => u + 1);\n        }\n      });\n\n      reloadList();\n    }\n\n    return () => listener?.unsubscribe?.();\n  }, [filterStr, sortStr]);\n\n  return {\n    channels,\n    error,\n    hasNextPage,\n    loadingChannels:\n      activeQueryType === 'queryLocalDB'\n        ? true\n        : (activeQueryType === 'reload' || activeQueryType === null) && channels === null,\n    loadingNextPage: activeQueryType === 'loadChannels',\n    loadNextPage: queryChannels,\n    refreshing: activeQueryType === 'refresh',\n    refreshList,\n    reloadList,\n    // Although channels can be null, there is no practical case where channels will be null\n    // when setChannels is used. setChannels is only recommended to be used for overriding\n    // event handler. Thus instead of adding if check for channels === null, its better to\n    // simply reassign types here.\n    setChannels,\n    staticChannelsActive,\n  };\n};\n"],"mappings":"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"}